{"ast":null,"code":"import _objectSpread from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nvar DEFAULT_OPTIONS = {\n  buffer: null,\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  // Bug #149: Safari does not yet support the detune AudioParam.\n  loop: false,\n  loopEnd: 0,\n  loopStart: 0,\n  playbackRate: 1\n};\nexport var createAudioBufferSourceNodeConstructor = function createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) {\n  return /*#__PURE__*/function (_audioNodeConstructor) {\n    _inherits(AudioBufferSourceNode, _audioNodeConstructor);\n\n    var _super = _createSuper(AudioBufferSourceNode);\n\n    function AudioBufferSourceNode(context, options) {\n      var _this;\n\n      _classCallCheck(this, AudioBufferSourceNode);\n\n      var nativeContext = getNativeContext(context);\n\n      var mergedOptions = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n\n      var nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n      var isOffline = isNativeOfflineAudioContext(nativeContext);\n      var audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer() : null;\n      _this = _super.call(this, context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n      _this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n      _this._isBufferNullified = false;\n      _this._isBufferSet = mergedOptions.buffer !== null;\n      _this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n      _this._onended = null; // Bug #73: Safari does not export the correct values for maxValue and minValue.\n\n      _this._playbackRate = createAudioParam(_assertThisInitialized(_this), isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      return _this;\n    }\n\n    _createClass(AudioBufferSourceNode, [{\n      key: \"buffer\",\n      get: function get() {\n        if (this._isBufferNullified) {\n          return null;\n        }\n\n        return this._nativeAudioBufferSourceNode.buffer;\n      },\n      set: function set(value) {\n        this._nativeAudioBufferSourceNode.buffer = value; // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n\n        if (value !== null) {\n          if (this._isBufferSet) {\n            throw createInvalidStateError();\n          }\n\n          this._isBufferSet = true;\n        }\n      }\n    }, {\n      key: \"loop\",\n      get: function get() {\n        return this._nativeAudioBufferSourceNode.loop;\n      },\n      set: function set(value) {\n        this._nativeAudioBufferSourceNode.loop = value;\n      }\n    }, {\n      key: \"loopEnd\",\n      get: function get() {\n        return this._nativeAudioBufferSourceNode.loopEnd;\n      },\n      set: function set(value) {\n        this._nativeAudioBufferSourceNode.loopEnd = value;\n      }\n    }, {\n      key: \"loopStart\",\n      get: function get() {\n        return this._nativeAudioBufferSourceNode.loopStart;\n      },\n      set: function set(value) {\n        this._nativeAudioBufferSourceNode.loopStart = value;\n      }\n    }, {\n      key: \"onended\",\n      get: function get() {\n        return this._onended;\n      },\n      set: function set(value) {\n        var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n        this._nativeAudioBufferSourceNode.onended = wrappedListener;\n        var nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n        this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n      }\n    }, {\n      key: \"playbackRate\",\n      get: function get() {\n        return this._playbackRate;\n      }\n    }, {\n      key: \"start\",\n      value: function start() {\n        var _this2 = this;\n\n        var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var duration = arguments.length > 2 ? arguments[2] : undefined;\n\n        this._nativeAudioBufferSourceNode.start(when, offset, duration);\n\n        if (this._audioBufferSourceNodeRenderer !== null) {\n          this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n        }\n\n        if (this.context.state !== 'closed') {\n          setInternalStateToActive(this);\n\n          var resetInternalStateToPassive = function resetInternalStateToPassive() {\n            _this2._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n            if (isActiveAudioNode(_this2)) {\n              setInternalStateToPassive(_this2);\n            }\n          };\n\n          this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n        }\n      }\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n        this._nativeAudioBufferSourceNode.stop(when);\n\n        if (this._audioBufferSourceNodeRenderer !== null) {\n          this._audioBufferSourceNodeRenderer.stop = when;\n        }\n      }\n    }]);\n\n    return AudioBufferSourceNode;\n  }(audioNodeConstructor);\n};","map":{"version":3,"mappings":"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","names":["MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","isActiveAudioNode","setInternalStateToActive","setInternalStateToPassive","DEFAULT_OPTIONS","buffer","channelCount","channelCountMode","channelInterpretation","loop","loopEnd","loopStart","playbackRate","createAudioBufferSourceNodeConstructor","audioNodeConstructor","createAudioBufferSourceNodeRenderer","createAudioParam","createInvalidStateError","createNativeAudioBufferSourceNode","getNativeContext","isNativeOfflineAudioContext","wrapEventListener","context","options","nativeContext","mergedOptions","nativeAudioBufferSourceNode","isOffline","audioBufferSourceNodeRenderer","_audioBufferSourceNodeRenderer","_isBufferNullified","_isBufferSet","_nativeAudioBufferSourceNode","_onended","_playbackRate","value","wrappedListener","onended","nativeOnEnded","when","offset","duration","start","undefined","state","resetInternalStateToPassive","removeEventListener","addEventListener","stop"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\standardized-audio-context\\src\\factories\\audio-buffer-source-node-constructor.ts"],"sourcesContent":["import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { IAudioBufferSourceNode, IAudioBufferSourceOptions, IAudioParam, IAudioScheduledSourceNodeEventMap } from '../interfaces';\nimport {\n    TAnyAudioBuffer,\n    TAudioBufferSourceNodeConstructorFactory,\n    TAudioBufferSourceNodeRenderer,\n    TContext,\n    TEventHandler,\n    TNativeAudioBufferSourceNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n} as const;\n\nexport const createAudioBufferSourceNodeConstructor: TAudioBufferSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioBufferSourceNodeRenderer,\n    createAudioParam,\n    createInvalidStateError,\n    createNativeAudioBufferSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class AudioBufferSourceNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IAudioBufferSourceNode<T>\n    {\n        private _audioBufferSourceNodeRenderer: TAudioBufferSourceNodeRenderer<T>;\n\n        private _isBufferNullified: boolean;\n\n        private _isBufferSet: boolean;\n\n        private _nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode;\n\n        private _onended: null | TEventHandler<this>;\n\n        private _playbackRate: IAudioParam;\n\n        constructor(context: T, options?: Partial<IAudioBufferSourceOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = <TAudioBufferSourceNodeRenderer<T>>(\n                (isOffline ? createAudioBufferSourceNodeRenderer() : null)\n            );\n\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = mergedOptions.buffer !== null;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Safari does not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(\n                this,\n                isOffline,\n                nativeAudioBufferSourceNode.playbackRate,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n        }\n\n        get buffer(): null | TAnyAudioBuffer {\n            if (this._isBufferNullified) {\n                return null;\n            }\n\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n\n        set buffer(value) {\n            this._nativeAudioBufferSourceNode.buffer = value;\n\n            // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n\n                this._isBufferSet = true;\n            }\n        }\n\n        get loop(): boolean {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n\n        get loopEnd(): number {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n\n        get loopStart(): number {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        get playbackRate(): IAudioParam {\n            return this._playbackRate;\n        }\n\n        public start(when = 0, offset = 0, duration?: number): void {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeAudioBufferSourceNode.stop(when);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}