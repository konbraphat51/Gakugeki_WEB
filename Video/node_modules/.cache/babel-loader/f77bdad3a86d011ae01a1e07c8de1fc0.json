{"ast":null,"code":"import _objectSpread from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"curve\", \"oversample\"];\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport var createNativeWaveShaperNodeFakerFactory = function createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError, createNativeGainNode, isDCCurve, monitorConnections) {\n  return function (nativeContext, _ref) {\n    var curve = _ref.curve,\n        oversample = _ref.oversample,\n        audioNodeOptions = _objectWithoutProperties(_ref, _excluded);\n\n    var negativeWaveShaperNode = nativeContext.createWaveShaper();\n    var positiveWaveShaperNode = nativeContext.createWaveShaper();\n    assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n    assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n    var inputGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: 1\n    }));\n    var invertGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: -1\n    }));\n    var outputGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: 1\n    }));\n    var revertGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: -1\n    }));\n    var disconnectNativeAudioBufferSourceNode = null;\n    var isConnected = false;\n    var unmodifiedCurve = null;\n    var nativeWaveShaperNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return negativeWaveShaperNode.channelCount;\n      },\n\n      set channelCount(value) {\n        inputGainNode.channelCount = value;\n        invertGainNode.channelCount = value;\n        negativeWaveShaperNode.channelCount = value;\n        outputGainNode.channelCount = value;\n        positiveWaveShaperNode.channelCount = value;\n        revertGainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return negativeWaveShaperNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        inputGainNode.channelCountMode = value;\n        invertGainNode.channelCountMode = value;\n        negativeWaveShaperNode.channelCountMode = value;\n        outputGainNode.channelCountMode = value;\n        positiveWaveShaperNode.channelCountMode = value;\n        revertGainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return negativeWaveShaperNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n        invertGainNode.channelInterpretation = value;\n        negativeWaveShaperNode.channelInterpretation = value;\n        outputGainNode.channelInterpretation = value;\n        positiveWaveShaperNode.channelInterpretation = value;\n        revertGainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return negativeWaveShaperNode.context;\n      },\n\n      get curve() {\n        return unmodifiedCurve;\n      },\n\n      set curve(value) {\n        // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n        if (value !== null && value.length < 2) {\n          throw createInvalidStateError();\n        }\n\n        if (value === null) {\n          negativeWaveShaperNode.curve = value;\n          positiveWaveShaperNode.curve = value;\n        } else {\n          var curveLength = value.length;\n          var negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n          var positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);\n          negativeCurve[0] = value[0];\n          positiveCurve[0] = -value[curveLength - 1];\n          var length = Math.ceil((curveLength + 1) / 2);\n          var centerIndex = (curveLength + 1) / 2 - 1;\n\n          for (var i = 1; i < length; i += 1) {\n            var theoreticIndex = i / length * centerIndex;\n            var lowerIndex = Math.floor(theoreticIndex);\n            var upperIndex = Math.ceil(theoreticIndex);\n            negativeCurve[i] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n            positiveCurve[i] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n          }\n\n          negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n          negativeWaveShaperNode.curve = negativeCurve;\n          positiveWaveShaperNode.curve = positiveCurve;\n        }\n\n        unmodifiedCurve = value;\n\n        if (isConnected) {\n          if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n          } else if (disconnectNativeAudioBufferSourceNode !== null) {\n            disconnectNativeAudioBufferSourceNode();\n            disconnectNativeAudioBufferSourceNode = null;\n          }\n        }\n      },\n\n      get inputs() {\n        return [inputGainNode];\n      },\n\n      get numberOfInputs() {\n        return negativeWaveShaperNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return negativeWaveShaperNode.numberOfOutputs;\n      },\n\n      get oversample() {\n        return negativeWaveShaperNode.oversample;\n      },\n\n      set oversample(value) {\n        negativeWaveShaperNode.oversample = value;\n        positiveWaveShaperNode.oversample = value;\n      },\n\n      addEventListener: function addEventListener() {\n        return inputGainNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n      dispatchEvent: function dispatchEvent() {\n        return inputGainNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n      removeEventListener: function removeEventListener() {\n        return inputGainNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      }\n    };\n\n    if (curve !== null) {\n      // Only values of type Float32Array can be assigned to the curve property.\n      nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n    }\n\n    if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n      nativeWaveShaperNodeFaker.oversample = oversample;\n    }\n\n    var whenConnected = function whenConnected() {\n      inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n      inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n      isConnected = true;\n\n      if (isDCCurve(unmodifiedCurve)) {\n        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n      }\n    };\n\n    var whenDisconnected = function whenDisconnected() {\n      inputGainNode.disconnect(negativeWaveShaperNode);\n      negativeWaveShaperNode.disconnect(outputGainNode);\n      inputGainNode.disconnect(invertGainNode);\n      invertGainNode.disconnect(positiveWaveShaperNode);\n      positiveWaveShaperNode.disconnect(revertGainNode);\n      revertGainNode.disconnect(outputGainNode);\n      isConnected = false;\n\n      if (disconnectNativeAudioBufferSourceNode !== null) {\n        disconnectNativeAudioBufferSourceNode();\n        disconnectNativeAudioBufferSourceNode = null;\n      }\n    };\n\n    return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"mappings":"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","names":["assignNativeAudioNodeOptions","interceptConnections","createNativeWaveShaperNodeFakerFactory","createConnectedNativeAudioBufferSourceNode","createInvalidStateError","createNativeGainNode","isDCCurve","monitorConnections","nativeContext","curve","oversample","audioNodeOptions","negativeWaveShaperNode","createWaveShaper","positiveWaveShaperNode","inputGainNode","gain","invertGainNode","outputGainNode","revertGainNode","disconnectNativeAudioBufferSourceNode","isConnected","unmodifiedCurve","nativeWaveShaperNodeFaker","bufferSize","undefined","channelCount","value","channelCountMode","channelInterpretation","context","length","curveLength","negativeCurve","Float32Array","positiveCurve","Math","ceil","centerIndex","i","theoreticIndex","lowerIndex","floor","upperIndex","inputs","numberOfInputs","numberOfOutputs","addEventListener","dispatchEvent","removeEventListener","whenConnected","connect","whenDisconnected","disconnect"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\standardized-audio-context\\src\\factories\\native-wave-shaper-node-faker-factory.ts"],"sourcesContent":["import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativeWaveShaperNode, TNativeWaveShaperNodeFakerFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFakerFactory: TNativeWaveShaperNodeFakerFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeGainNode,\n    isDCCurve,\n    monitorConnections\n) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = nativeContext.createWaveShaper();\n        const positiveWaveShaperNode = nativeContext.createWaveShaper();\n\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n        let unmodifiedCurve: null | TNativeWaveShaperNode['curve'] = null;\n\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeWaveShaperNode['channelCountMode'] {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeWaveShaperNode['channelInterpretation'] {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeWaveShaperNode['context'] {\n                return negativeWaveShaperNode.context;\n            },\n            get curve(): TNativeWaveShaperNode['curve'] {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (value !== null && value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                } else {\n                    const curveLength = value.length;\n\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = (curveLength + 1) / 2 - 1;\n\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        negativeCurve[i] =\n                            lowerIndex === upperIndex\n                                ? value[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                        positiveCurve[i] =\n                            lowerIndex === upperIndex\n                                ? -value[curveLength - 1 - lowerIndex]\n                                : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) -\n                                  (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n                    }\n\n                    negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n\n                unmodifiedCurve = value;\n\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    } else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample(): TNativeWaveShaperNode['oversample'] {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        if (curve !== null) {\n            // Only values of type Float32Array can be assigned to the curve property.\n            nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n        }\n\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n\n        const whenConnected = () => {\n            inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n\n            inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n\n            isConnected = true;\n\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n"]},"metadata":{},"sourceType":"module"}