{"ast":null,"code":"import _classCallCheck from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _toConsumableArray from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\n\nvar addConnectionToAudioParamOfAudioContext = function addConnectionToAudioParamOfAudioContext(source, destination, output, isOffline) {\n  var _getAudioParamConnect = getAudioParamConnections(destination),\n      activeInputs = _getAudioParamConnect.activeInputs,\n      passiveInputs = _getAudioParamConnect.passiveInputs;\n\n  var _getAudioNodeConnecti = getAudioNodeConnections(source),\n      outputs = _getAudioNodeConnecti.outputs;\n\n  var eventListeners = getEventListenersOfAudioNode(source);\n\n  var eventListener = function eventListener(isActive) {\n    var nativeAudioNode = getNativeAudioNode(source);\n    var nativeAudioParam = getNativeAudioParam(destination);\n\n    if (isActive) {\n      var partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n      addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.connect(nativeAudioParam, output);\n      }\n    } else {\n      var _partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n\n      addPassiveInputConnectionToAudioParam(passiveInputs, _partialConnection, false);\n\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.disconnect(nativeAudioParam, output);\n      }\n    }\n  };\n\n  if (insertElementInSet(outputs, [destination, output], function (outputConnection) {\n    return outputConnection[0] === destination && outputConnection[1] === output;\n  }, true)) {\n    eventListeners.add(eventListener);\n\n    if (isActiveAudioNode(source)) {\n      addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n    } else {\n      addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nvar deleteInputConnectionOfAudioNode = function deleteInputConnectionOfAudioNode(source, destination, output, input) {\n  var _getAudioNodeConnecti2 = getAudioNodeConnections(destination),\n      activeInputs = _getAudioNodeConnecti2.activeInputs,\n      passiveInputs = _getAudioNodeConnecti2.passiveInputs;\n\n  var activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n  if (activeInputConnection === null) {\n    var passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n    return [passiveInputConnection[2], false];\n  }\n\n  return [activeInputConnection[2], true];\n};\n\nvar deleteInputConnectionOfAudioParam = function deleteInputConnectionOfAudioParam(source, destination, output) {\n  var _getAudioParamConnect2 = getAudioParamConnections(destination),\n      activeInputs = _getAudioParamConnect2.activeInputs,\n      passiveInputs = _getAudioParamConnect2.passiveInputs;\n\n  var activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n  if (activeInputConnection === null) {\n    var passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n    return [passiveInputConnection[1], false];\n  }\n\n  return [activeInputConnection[2], true];\n};\n\nvar deleteInputsOfAudioNode = function deleteInputsOfAudioNode(source, isOffline, destination, output, input) {\n  var _deleteInputConnectio = deleteInputConnectionOfAudioNode(source, destination, output, input),\n      _deleteInputConnectio2 = _slicedToArray(_deleteInputConnectio, 2),\n      listener = _deleteInputConnectio2[0],\n      isActive = _deleteInputConnectio2[1];\n\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n    }\n  }\n\n  if (isActiveAudioNode(destination)) {\n    var _getAudioNodeConnecti3 = getAudioNodeConnections(destination),\n        activeInputs = _getAudioNodeConnecti3.activeInputs;\n\n    setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n  }\n};\n\nvar deleteInputsOfAudioParam = function deleteInputsOfAudioParam(source, isOffline, destination, output) {\n  var _deleteInputConnectio3 = deleteInputConnectionOfAudioParam(source, destination, output),\n      _deleteInputConnectio4 = _slicedToArray(_deleteInputConnectio3, 2),\n      listener = _deleteInputConnectio4[0],\n      isActive = _deleteInputConnectio4[1];\n\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n    }\n  }\n};\n\nvar deleteAnyConnection = function deleteAnyConnection(source, isOffline) {\n  var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  var destinations = [];\n\n  var _iterator = _createForOfIteratorHelper(audioNodeConnectionsOfSource.outputs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var outputConnection = _step.value;\n\n      if (isAudioNodeOutputConnection(outputConnection)) {\n        deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n      } else {\n        deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n      }\n\n      destinations.push(outputConnection[0]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  audioNodeConnectionsOfSource.outputs.clear();\n  return destinations;\n};\n\nvar deleteConnectionAtOutput = function deleteConnectionAtOutput(source, isOffline, output) {\n  var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  var destinations = [];\n\n  var _iterator2 = _createForOfIteratorHelper(audioNodeConnectionsOfSource.outputs),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var outputConnection = _step2.value;\n\n      if (outputConnection[1] === output) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n          deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n        } else {\n          deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n        }\n\n        destinations.push(outputConnection[0]);\n        audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return destinations;\n};\n\nvar deleteConnectionToDestination = function deleteConnectionToDestination(source, isOffline, destination, output, input) {\n  var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  return Array.from(audioNodeConnectionsOfSource.outputs).filter(function (outputConnection) {\n    return outputConnection[0] === destination && (output === undefined || outputConnection[1] === output) && (input === undefined || outputConnection[2] === input);\n  }).map(function (outputConnection) {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n    } else {\n      deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n    }\n\n    audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    return outputConnection[0];\n  });\n};\n\nexport var createAudioNodeConstructor = function createAudioNodeConstructor(addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor) {\n  return /*#__PURE__*/function (_eventTargetConstruct) {\n    _inherits(AudioNode, _eventTargetConstruct);\n\n    var _super = _createSuper(AudioNode);\n\n    function AudioNode(context, isActive, nativeAudioNode, audioNodeRenderer) {\n      var _this;\n\n      _classCallCheck(this, AudioNode);\n\n      _this = _super.call(this, nativeAudioNode);\n      _this._context = context;\n      _this._nativeAudioNode = nativeAudioNode;\n      var nativeContext = getNativeContext(context); // Bug #12: Safari does not support to disconnect a specific destination.\n\n      if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, function () {\n        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n      })) {\n        wrapAudioNodeDisconnectMethod(nativeAudioNode);\n      }\n\n      AUDIO_NODE_STORE.set(_assertThisInitialized(_this), nativeAudioNode);\n      EVENT_LISTENERS.set(_assertThisInitialized(_this), new Set());\n\n      if (context.state !== 'closed' && isActive) {\n        setInternalStateToActive(_assertThisInitialized(_this));\n      }\n\n      addAudioNodeConnections(_assertThisInitialized(_this), audioNodeRenderer, nativeAudioNode);\n      return _this;\n    }\n\n    _createClass(AudioNode, [{\n      key: \"channelCount\",\n      get: function get() {\n        return this._nativeAudioNode.channelCount;\n      },\n      set: function set(value) {\n        this._nativeAudioNode.channelCount = value;\n      }\n    }, {\n      key: \"channelCountMode\",\n      get: function get() {\n        return this._nativeAudioNode.channelCountMode;\n      },\n      set: function set(value) {\n        this._nativeAudioNode.channelCountMode = value;\n      }\n    }, {\n      key: \"channelInterpretation\",\n      get: function get() {\n        return this._nativeAudioNode.channelInterpretation;\n      },\n      set: function set(value) {\n        this._nativeAudioNode.channelInterpretation = value;\n      }\n    }, {\n      key: \"context\",\n      get: function get() {\n        return this._context;\n      }\n    }, {\n      key: \"numberOfInputs\",\n      get: function get() {\n        return this._nativeAudioNode.numberOfInputs;\n      }\n    }, {\n      key: \"numberOfOutputs\",\n      get: function get() {\n        return this._nativeAudioNode.numberOfOutputs;\n      } // tslint:disable-next-line:invalid-void\n\n    }, {\n      key: \"connect\",\n      value: function connect(destination) {\n        var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n        // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n        if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n          throw createIndexSizeError();\n        }\n\n        var nativeContext = getNativeContext(this._context);\n        var isOffline = isNativeOfflineAudioContext(nativeContext);\n\n        if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n          throw createInvalidAccessError();\n        }\n\n        if (isAudioNode(destination)) {\n          var nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n          try {\n            var connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n            var isPassive = isPassiveAudioNode(this);\n\n            if (isOffline || isPassive) {\n              var _this$_nativeAudioNod;\n\n              (_this$_nativeAudioNod = this._nativeAudioNode).disconnect.apply(_this$_nativeAudioNod, _toConsumableArray(connection));\n            }\n\n            if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n              setInternalStateToActive(destination);\n            }\n          } catch (err) {\n            // Bug #41: Safari does not throw the correct exception so far.\n            if (err.code === 12) {\n              throw createInvalidAccessError();\n            }\n\n            throw err;\n          }\n\n          var isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline); // Bug #164: Only Firefox detects cycles so far.\n\n          if (isNewConnectionToAudioNode) {\n            var cycles = detectCycles([this], destination);\n            visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n          }\n\n          return destination;\n        }\n\n        var nativeAudioParam = getNativeAudioParam(destination);\n        /*\n         * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n         * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n         * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n         */\n\n        if (nativeAudioParam.name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n          throw createNotSupportedError();\n        }\n\n        try {\n          this._nativeAudioNode.connect(nativeAudioParam, output);\n\n          if (isOffline || isPassiveAudioNode(this)) {\n            this._nativeAudioNode.disconnect(nativeAudioParam, output);\n          }\n        } catch (err) {\n          // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n          if (err.code === 12) {\n            throw createInvalidAccessError();\n          }\n\n          throw err;\n        }\n\n        var isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline); // Bug #164: Only Firefox detects cycles so far.\n\n        if (isNewConnectionToAudioParam) {\n          var _cycles = detectCycles([this], destination);\n\n          visitEachAudioNodeOnce(_cycles, createIncrementCycleCounter(isOffline));\n        }\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect(destinationOrOutput, output, input) {\n        var destinations;\n        var nativeContext = getNativeContext(this._context);\n        var isOffline = isNativeOfflineAudioContext(nativeContext);\n\n        if (destinationOrOutput === undefined) {\n          destinations = deleteAnyConnection(this, isOffline);\n        } else if (typeof destinationOrOutput === 'number') {\n          if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n            throw createIndexSizeError();\n          }\n\n          destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n        } else {\n          if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n            throw createIndexSizeError();\n          }\n\n          if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n            throw createIndexSizeError();\n          }\n\n          destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n          if (destinations.length === 0) {\n            throw createInvalidAccessError();\n          }\n        } // Bug #164: Only Firefox detects cycles so far.\n\n\n        var _iterator3 = _createForOfIteratorHelper(destinations),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var destination = _step3.value;\n            var cycles = detectCycles([this], destination);\n            visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }]);\n\n    return AudioNode;\n  }(eventTargetConstructor);\n};","map":{"version":3,"mappings":";;;;;;;;AAAA,SAASA,gBAAT,EAA2BC,eAA3B,QAAkD,YAAlD;AACA,SAASC,WAAT,QAA4B,sBAA5B;AACA,SAASC,2BAAT,QAA4C,wCAA5C;AACA,SAASC,oCAAT,QAAqD,uDAArD;AACA,SAASC,qCAAT,QAAsD,wDAAtD;AACA,SAASC,uCAAT,QAAwD,2DAAxD;AACA,SAASC,2BAAT,QAA4C,2CAA5C;AACA,SAASC,uCAAT,QAAwD,0DAAxD;AACA,SAASC,8BAAT,QAA+C,iDAA/C;AACA,SAASC,uCAAT,QAAwD,0DAAxD;AACA,SAASC,wCAAT,QAAyD,2DAAzD;AACA,SAASC,4CAAT,QAA6D,gEAA7D;AACA,SAASC,uBAAT,QAAwC,uCAAxC;AACA,SAASC,wBAAT,QAAyC,wCAAzC;AACA,SAASC,4BAAT,QAA6C,8CAA7C;AACA,SAASC,kBAAT,QAAmC,kCAAnC;AACA,SAASC,mBAAT,QAAoC,mCAApC;AACA,SAASC,kBAAT,QAAmC,kCAAnC;AACA,SAASC,iBAAT,QAAkC,iCAAlC;AACA,SAASC,cAAT,QAA+B,+BAA/B;AACA,SAASC,kBAAT,QAAmC,kCAAnC;AACA,SAASC,wBAAT,QAAyC,yCAAzC;AACA,SAASC,sCAAT,QAAuD,yDAAvD;AACA,SAASC,oCAAT,QAAqD,sDAArD;AACA,SAASC,sBAAT,QAAuC,uCAAvC;AACA,SAASC,6BAAT,QAA8C,8CAA9C;;AAmBA,IAAMC,uCAAuC,GAAG,SAA1CA,uCAA0C,CAC5CC,MAD4C,EAE5CC,WAF4C,EAG5CC,MAH4C,EAI5CC,SAJ4C,EAKnC;EACT,4BAAwCjB,wBAAwB,CAAIe,WAAJ,CAAhE;EAAA,IAAQG,YAAR,yBAAQA,YAAR;EAAA,IAAsBC,aAAtB,yBAAsBA,aAAtB;;EACA,4BAAoBpB,uBAAuB,CAACe,MAAD,CAA3C;EAAA,IAAQM,OAAR,yBAAQA,OAAR;;EACA,IAAMC,cAAc,GAAGpB,4BAA4B,CAACa,MAAD,CAAnD;;EAEA,IAAMQ,aAAa,GAAgC,SAA7CA,aAA6C,CAACC,QAAD,EAAa;IAC5D,IAAMC,eAAe,GAAGtB,kBAAkB,CAACY,MAAD,CAA1C;IACA,IAAMW,gBAAgB,GAAGtB,mBAAmB,CAACY,WAAD,CAA5C;;IAEA,IAAIQ,QAAJ,EAAc;MACV,IAAMG,iBAAiB,GAAG7B,wCAAwC,CAACsB,aAAD,EAAgBL,MAAhB,EAAwBE,MAAxB,CAAlE;MAEA1B,oCAAoC,CAAC4B,YAAD,EAAeJ,MAAf,EAAuBY,iBAAvB,EAA0C,KAA1C,CAApC;;MAEA,IAAI,CAACT,SAAD,IAAc,CAACX,cAAc,CAACQ,MAAD,CAAjC,EAA2C;QACvCU,eAAe,CAACG,OAAhB,CAAwBF,gBAAxB,EAA0CT,MAA1C;MACH;IACJ,CARD,MAQO;MACH,IAAMU,kBAAiB,GAAGhC,uCAAuC,CAACwB,YAAD,EAAeJ,MAAf,EAAuBE,MAAvB,CAAjE;;MAEAzB,qCAAqC,CAAC4B,aAAD,EAAgBO,kBAAhB,EAAmC,KAAnC,CAArC;;MAEA,IAAI,CAACT,SAAD,IAAc,CAACX,cAAc,CAACQ,MAAD,CAAjC,EAA2C;QACvCU,eAAe,CAACI,UAAhB,CAA2BH,gBAA3B,EAA6CT,MAA7C;MACH;IACJ;EACJ,CArBD;;EAuBA,IACIZ,kBAAkB,CACdgB,OADc,EAEd,CAACL,WAAD,EAAcC,MAAd,CAFc,EAGd,UAACa,gBAAD;IAAA,OAAsBA,gBAAgB,CAAC,CAAD,CAAhB,KAAwBd,WAAxB,IAAuCc,gBAAgB,CAAC,CAAD,CAAhB,KAAwBb,MAArF;EAAA,CAHc,EAId,IAJc,CADtB,EAOE;IACEK,cAAc,CAACS,GAAf,CAAmBR,aAAnB;;IAEA,IAAIjB,iBAAiB,CAACS,MAAD,CAArB,EAA+B;MAC3BxB,oCAAoC,CAAC4B,YAAD,EAAeJ,MAAf,EAAuB,CAACE,MAAD,EAASM,aAAT,CAAvB,EAAgD,IAAhD,CAApC;IACH,CAFD,MAEO;MACH/B,qCAAqC,CAAC4B,aAAD,EAAgB,CAACL,MAAD,EAASE,MAAT,EAAiBM,aAAjB,CAAhB,EAAiD,IAAjD,CAArC;IACH;;IAED,OAAO,IAAP;EACH;;EAED,OAAO,KAAP;AACH,CArDD;;AAuDA,IAAMS,gCAAgC,GAAG,SAAnCA,gCAAmC,CACrCjB,MADqC,EAErCC,WAFqC,EAGrCC,MAHqC,EAIrCgB,KAJqC,EAKU;EAC/C,6BAAwCjC,uBAAuB,CAACgB,WAAD,CAA/D;EAAA,IAAQG,YAAR,0BAAQA,YAAR;EAAA,IAAsBC,aAAtB,0BAAsBA,aAAtB;;EAEA,IAAMc,qBAAqB,GAAGxC,2BAA2B,CAACyB,YAAY,CAACc,KAAD,CAAb,EAAsBlB,MAAtB,EAA8BE,MAA9B,CAAzD;;EAEA,IAAIiB,qBAAqB,KAAK,IAA9B,EAAoC;IAChC,IAAMC,sBAAsB,GAAGtC,uCAAuC,CAACuB,aAAD,EAAgBL,MAAhB,EAAwBE,MAAxB,EAAgCgB,KAAhC,CAAtE;IAEA,OAAO,CAACE,sBAAsB,CAAC,CAAD,CAAvB,EAA4B,KAA5B,CAAP;EACH;;EAED,OAAO,CAACD,qBAAqB,CAAC,CAAD,CAAtB,EAA2B,IAA3B,CAAP;AACH,CAjBD;;AAmBA,IAAME,iCAAiC,GAAG,SAApCA,iCAAoC,CACtCrB,MADsC,EAEtCC,WAFsC,EAGtCC,MAHsC,EAIS;EAC/C,6BAAwChB,wBAAwB,CAAIe,WAAJ,CAAhE;EAAA,IAAQG,YAAR,0BAAQA,YAAR;EAAA,IAAsBC,aAAtB,0BAAsBA,aAAtB;;EAEA,IAAMc,qBAAqB,GAAGxC,2BAA2B,CAACyB,YAAD,EAAeJ,MAAf,EAAuBE,MAAvB,CAAzD;;EAEA,IAAIiB,qBAAqB,KAAK,IAA9B,EAAoC;IAChC,IAAMC,sBAAsB,GAAGrC,wCAAwC,CAACsB,aAAD,EAAgBL,MAAhB,EAAwBE,MAAxB,CAAvE;IAEA,OAAO,CAACkB,sBAAsB,CAAC,CAAD,CAAvB,EAA4B,KAA5B,CAAP;EACH;;EAED,OAAO,CAACD,qBAAqB,CAAC,CAAD,CAAtB,EAA2B,IAA3B,CAAP;AACH,CAhBD;;AAkBA,IAAMG,uBAAuB,GAAG,SAA1BA,uBAA0B,CAC5BtB,MAD4B,EAE5BG,SAF4B,EAG5BF,WAH4B,EAI5BC,MAJ4B,EAK5BgB,KAL4B,EAM5B;EACA,4BAA6BD,gCAAgC,CAACjB,MAAD,EAASC,WAAT,EAAsBC,MAAtB,EAA8BgB,KAA9B,CAA7D;EAAA;EAAA,IAAOK,QAAP;EAAA,IAAiBd,QAAjB;;EAEA,IAAIc,QAAQ,KAAK,IAAjB,EAAuB;IACnB1C,8BAA8B,CAACmB,MAAD,EAASuB,QAAT,CAA9B;;IAEA,IAAId,QAAQ,IAAI,CAACN,SAAb,IAA0B,CAACX,cAAc,CAACQ,MAAD,CAA7C,EAAuD;MACnDhB,4CAA4C,CAACI,kBAAkB,CAACY,MAAD,CAAnB,EAA6BZ,kBAAkB,CAACa,WAAD,CAA/C,EAA8DC,MAA9D,EAAsEgB,KAAtE,CAA5C;IACH;EACJ;;EAED,IAAI3B,iBAAiB,CAACU,WAAD,CAArB,EAAoC;IAChC,6BAAyBhB,uBAAuB,CAACgB,WAAD,CAAhD;IAAA,IAAQG,YAAR,0BAAQA,YAAR;;IAEAT,sCAAsC,CAACM,WAAD,EAAcG,YAAd,CAAtC;EACH;AACJ,CAtBD;;AAwBA,IAAMoB,wBAAwB,GAAG,SAA3BA,wBAA2B,CAC7BxB,MAD6B,EAE7BG,SAF6B,EAG7BF,WAH6B,EAI7BC,MAJ6B,EAK7B;EACA,6BAA6BmB,iCAAiC,CAACrB,MAAD,EAASC,WAAT,EAAsBC,MAAtB,CAA9D;EAAA;EAAA,IAAOqB,QAAP;EAAA,IAAiBd,QAAjB;;EAEA,IAAIc,QAAQ,KAAK,IAAjB,EAAuB;IACnB1C,8BAA8B,CAACmB,MAAD,EAASuB,QAAT,CAA9B;;IAEA,IAAId,QAAQ,IAAI,CAACN,SAAb,IAA0B,CAACX,cAAc,CAACQ,MAAD,CAA7C,EAAuD;MACnDZ,kBAAkB,CAACY,MAAD,CAAlB,CAA2Bc,UAA3B,CAAsCzB,mBAAmB,CAACY,WAAD,CAAzD,EAAwEC,MAAxE;IACH;EACJ;AACJ,CAfD;;AAiBA,IAAMuB,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAqBzB,MAArB,EAA4CG,SAA5C,EAAmG;EAC3H,IAAMuB,4BAA4B,GAAGzC,uBAAuB,CAACe,MAAD,CAA5D;EACA,IAAM2B,YAAY,GAAG,EAArB;;EAF2H,2CAI5FD,4BAA4B,CAACpB,OAJ+D;EAAA;;EAAA;IAI3H,oDAAqE;MAAA,IAA1DS,gBAA0D;;MACjE,IAAIxC,2BAA2B,CAACwC,gBAAD,CAA/B,EAAmD;QAC/CO,uBAAuB,MAAvB,UAAwBtB,MAAxB,EAAgCG,SAAhC,4BAA8CY,gBAA9C;MACH,CAFD,MAEO;QACHS,wBAAwB,MAAxB,UAAyBxB,MAAzB,EAAiCG,SAAjC,4BAA+CY,gBAA/C;MACH;;MAEDY,YAAY,CAACC,IAAb,CAAkBb,gBAAgB,CAAC,CAAD,CAAlC;IACH;EAZ0H;IAAA;EAAA;IAAA;EAAA;;EAc3HW,4BAA4B,CAACpB,OAA7B,CAAqCuB,KAArC;EAEA,OAAOF,YAAP;AACH,CAjBD;;AAmBA,IAAMG,wBAAwB,GAAG,SAA3BA,wBAA2B,CAC7B9B,MAD6B,EAE7BG,SAF6B,EAG7BD,MAH6B,EAII;EACjC,IAAMwB,4BAA4B,GAAGzC,uBAAuB,CAACe,MAAD,CAA5D;EACA,IAAM2B,YAAY,GAAG,EAArB;;EAFiC,4CAIFD,4BAA4B,CAACpB,OAJ3B;EAAA;;EAAA;IAIjC,uDAAqE;MAAA,IAA1DS,gBAA0D;;MACjE,IAAIA,gBAAgB,CAAC,CAAD,CAAhB,KAAwBb,MAA5B,EAAoC;QAChC,IAAI3B,2BAA2B,CAACwC,gBAAD,CAA/B,EAAmD;UAC/CO,uBAAuB,MAAvB,UAAwBtB,MAAxB,EAAgCG,SAAhC,4BAA8CY,gBAA9C;QACH,CAFD,MAEO;UACHS,wBAAwB,MAAxB,UAAyBxB,MAAzB,EAAiCG,SAAjC,4BAA+CY,gBAA/C;QACH;;QAEDY,YAAY,CAACC,IAAb,CAAkBb,gBAAgB,CAAC,CAAD,CAAlC;QACAW,4BAA4B,CAACpB,OAA7B,CAAqCyB,MAArC,CAA4ChB,gBAA5C;MACH;IACJ;EAfgC;IAAA;EAAA;IAAA;EAAA;;EAiBjC,OAAOY,YAAP;AACH,CAtBD;;AAwBA,IAAMK,6BAA6B,GAAG,SAAhCA,6BAAgC,CAClChC,MADkC,EAElCG,SAFkC,EAGlCF,WAHkC,EAIlCC,MAJkC,EAKlCgB,KALkC,EAMD;EACjC,IAAMQ,4BAA4B,GAAGzC,uBAAuB,CAACe,MAAD,CAA5D;EAEA,OAAOiC,KAAK,CAACC,IAAN,CAAWR,4BAA4B,CAACpB,OAAxC,EACF6B,MADE,CAEC,UAACpB,gBAAD;IAAA,OACIA,gBAAgB,CAAC,CAAD,CAAhB,KAAwBd,WAAxB,KACCC,MAAM,KAAKkC,SAAX,IAAwBrB,gBAAgB,CAAC,CAAD,CAAhB,KAAwBb,MADjD,MAECgB,KAAK,KAAKkB,SAAV,IAAuBrB,gBAAgB,CAAC,CAAD,CAAhB,KAAwBG,KAFhD,CADJ;EAAA,CAFD,EAOFmB,GAPE,CAOE,UAACtB,gBAAD,EAAqB;IACtB,IAAIxC,2BAA2B,CAACwC,gBAAD,CAA/B,EAAmD;MAC/CO,uBAAuB,MAAvB,UAAwBtB,MAAxB,EAAgCG,SAAhC,4BAA8CY,gBAA9C;IACH,CAFD,MAEO;MACHS,wBAAwB,MAAxB,UAAyBxB,MAAzB,EAAiCG,SAAjC,4BAA+CY,gBAA/C;IACH;;IAEDW,4BAA4B,CAACpB,OAA7B,CAAqCyB,MAArC,CAA4ChB,gBAA5C;IAEA,OAAOA,gBAAgB,CAAC,CAAD,CAAvB;EACH,CAjBE,CAAP;AAkBH,CA3BD;;AA6BA,OAAO,IAAMuB,0BAA0B,GAAiC,SAA3DA,0BAA2D,CACpEC,uBADoE,EAEpEC,wBAFoE,EAGpEC,eAHoE,EAIpEC,2BAJoE,EAKpEC,oBALoE,EAMpEC,wBANoE,EAOpEC,uBAPoE,EAQpEC,qBARoE,EASpEC,YAToE,EAUpEC,sBAVoE,EAWpEC,gBAXoE,EAYpEC,oBAZoE,EAapEC,iBAboE,EAcpEC,kBAdoE,EAepEC,2BAfoE,EAgBpEC,iCAhBoE,EAiBpE;EACA;IAAA;;IAAA;;IAQI,mBACIC,OADJ,EAEI9C,QAFJ,EAGIC,eAHJ,EAII8C,iBAJJ,EAIiI;MAAA;;MAAA;;MAE7H,0BAAM9C,eAAN;MAEA,MAAK+C,QAAL,GAAgBF,OAAhB;MACA,MAAKG,gBAAL,GAAwBhD,eAAxB;MAEA,IAAMiD,aAAa,GAAGV,gBAAgB,CAACM,OAAD,CAAtC,CAP6H,CAS7H;;MACA,IACIL,oBAAoB,CAACS,aAAD,CAApB,IACA,SACIlB,eAAe,CAAC7C,oCAAD,EAAuC,YAAK;QACvD,OAAOA,oCAAoC,CAAC+D,aAAD,EAAgBL,iCAAhB,CAA3C;MACH,CAFc,CAHvB,EAME;QACExD,6BAA6B,CAACY,eAAD,CAA7B;MACH;;MAEDtC,gBAAgB,CAACwF,GAAjB,gCAA2BlD,eAA3B;MACArC,eAAe,CAACuF,GAAhB,gCAA0B,IAAIC,GAAJ,EAA1B;;MAEA,IAAIN,OAAO,CAACO,KAAR,KAAkB,QAAlB,IAA8BrD,QAAlC,EAA4C;QACxCf,wBAAwB,+BAAxB;MACH;;MAED6C,uBAAuB,gCAAOiB,iBAAP,EAA0B9C,eAA1B,CAAvB;MA3B6H;IA4BhI;;IAxCL;MAAA;MAAA,KA0CI,eAAgB;QACZ,OAAO,KAAKgD,gBAAL,CAAsBK,YAA7B;MACH,CA5CL;MAAA,KA8CI,aAAiBC,KAAjB,EAAsB;QAClB,KAAKN,gBAAL,CAAsBK,YAAtB,GAAqCC,KAArC;MACH;IAhDL;MAAA;MAAA,KAkDI,eAAoB;QAChB,OAAO,KAAKN,gBAAL,CAAsBO,gBAA7B;MACH,CApDL;MAAA,KAsDI,aAAqBD,KAArB,EAA0B;QACtB,KAAKN,gBAAL,CAAsBO,gBAAtB,GAAyCD,KAAzC;MACH;IAxDL;MAAA;MAAA,KA0DI,eAAyB;QACrB,OAAO,KAAKN,gBAAL,CAAsBQ,qBAA7B;MACH,CA5DL;MAAA,KA8DI,aAA0BF,KAA1B,EAA+B;QAC3B,KAAKN,gBAAL,CAAsBQ,qBAAtB,GAA8CF,KAA9C;MACH;IAhEL;MAAA;MAAA,KAkEI,eAAW;QACP,OAAO,KAAKP,QAAZ;MACH;IApEL;MAAA;MAAA,KAsEI,eAAkB;QACd,OAAO,KAAKC,gBAAL,CAAsBS,cAA7B;MACH;IAxEL;MAAA;MAAA,KA0EI,eAAmB;QACf,OAAO,KAAKT,gBAAL,CAAsBU,eAA7B;MACH,CA5EL,CAgFI;;IAhFJ;MAAA;MAAA,OAiFW,iBAAqDnE,WAArD,EAAwG;QAAA,IAArBC,MAAqB,uEAAZ,CAAY;QAAA,IAATgB,KAAS,uEAAD,CAAC;;QAC3G;QACA,IAAIhB,MAAM,GAAG,CAAT,IAAcA,MAAM,IAAI,KAAKwD,gBAAL,CAAsBU,eAAlD,EAAmE;UAC/D,MAAMzB,oBAAoB,EAA1B;QACH;;QAED,IAAMgB,aAAa,GAAGV,gBAAgB,CAAC,KAAKQ,QAAN,CAAtC;QACA,IAAMtD,SAAS,GAAGkD,2BAA2B,CAACM,aAAD,CAA7C;;QAEA,IAAIR,iBAAiB,CAAClD,WAAD,CAAjB,IAAkCmD,kBAAkB,CAACnD,WAAD,CAAxD,EAAuE;UACnE,MAAM2C,wBAAwB,EAA9B;QACH;;QAED,IAAItE,WAAW,CAAC2B,WAAD,CAAf,EAA8B;UAC1B,IAAMoE,0BAA0B,GAAGjF,kBAAkB,CAACa,WAAD,CAArD;;UAEA,IAAI;YACA,IAAMqE,UAAU,GAAG5F,uCAAuC,CACtD,KAAKgF,gBADiD,EAEtDW,0BAFsD,EAGtDnE,MAHsD,EAItDgB,KAJsD,CAA1D;YAOA,IAAMqD,SAAS,GAAG9E,kBAAkB,CAAC,IAAD,CAApC;;YAEA,IAAIU,SAAS,IAAIoE,SAAjB,EAA4B;cAAA;;cACxB,8BAAKb,gBAAL,EAAsB5C,UAAtB,iDAAoCwD,UAApC;YACH;;YAED,IAAI,KAAKf,OAAL,CAAaO,KAAb,KAAuB,QAAvB,IAAmC,CAACS,SAApC,IAAiD9E,kBAAkB,CAACQ,WAAD,CAAvE,EAAsF;cAClFP,wBAAwB,CAACO,WAAD,CAAxB;YACH;UACJ,CAjBD,CAiBE,OAAOuE,GAAP,EAAY;YACV;YACA,IAAIA,GAAG,CAACC,IAAJ,KAAa,EAAjB,EAAqB;cACjB,MAAM7B,wBAAwB,EAA9B;YACH;;YAED,MAAM4B,GAAN;UACH;;UAED,IAAME,0BAA0B,GAAGlC,wBAAwB,CACvD,IADuD,EAEjCvC,WAFiC,EAGvDC,MAHuD,EAIvDgB,KAJuD,EAKvDf,SALuD,CAA3D,CA7B0B,CAqC1B;;UACA,IAAIuE,0BAAJ,EAAgC;YAC5B,IAAMC,MAAM,GAAG5B,YAAY,CAAC,CAAC,IAAD,CAAD,EAAkC9C,WAAlC,CAA3B;YAEAJ,sBAAsB,CAAC8E,MAAD,EAASjC,2BAA2B,CAACvC,SAAD,CAApC,CAAtB;UACH;;UAED,OAAOF,WAAP;QACH;;QAED,IAAMU,gBAAgB,GAAGtB,mBAAmB,CAACY,WAAD,CAA5C;QAEA;;;;;;QAKA,IAA2CU,gBAAiB,CAACiE,IAAlB,KAA2B,cAA3B,IAA6CjE,gBAAgB,CAACkE,QAAjB,KAA8B,IAAtH,EAA4H;UACxH,MAAMhC,uBAAuB,EAA7B;QACH;;QAED,IAAI;UACA,KAAKa,gBAAL,CAAsB7C,OAAtB,CAA8BF,gBAA9B,EAAgDT,MAAhD;;UAEA,IAAIC,SAAS,IAAIV,kBAAkB,CAAC,IAAD,CAAnC,EAA2C;YACvC,KAAKiE,gBAAL,CAAsB5C,UAAtB,CAAiCH,gBAAjC,EAAmDT,MAAnD;UACH;QACJ,CAND,CAME,OAAOsE,GAAP,EAAY;UACV;UACA,IAAIA,GAAG,CAACC,IAAJ,KAAa,EAAjB,EAAqB;YACjB,MAAM7B,wBAAwB,EAA9B;UACH;;UAED,MAAM4B,GAAN;QACH;;QAED,IAAMM,2BAA2B,GAAG/E,uCAAuC,CAAC,IAAD,EAAOE,WAAP,EAAoBC,MAApB,EAA4BC,SAA5B,CAA3E,CAtF2G,CAwF3G;;QACA,IAAI2E,2BAAJ,EAAiC;UAC7B,IAAMH,OAAM,GAAG5B,YAAY,CAAC,CAAC,IAAD,CAAD,EAAS9C,WAAT,CAA3B;;UAEAJ,sBAAsB,CAAC8E,OAAD,EAASjC,2BAA2B,CAACvC,SAAD,CAApC,CAAtB;QACH;MACJ;IA/KL;MAAA;MAAA,OAoLW,oBACH4E,mBADG,EAEH7E,MAFG,EAGHgB,KAHG,EAGW;QAEd,IAAIS,YAAJ;QAEA,IAAMgC,aAAa,GAAGV,gBAAgB,CAAC,KAAKQ,QAAN,CAAtC;QACA,IAAMtD,SAAS,GAAGkD,2BAA2B,CAACM,aAAD,CAA7C;;QAEA,IAAIoB,mBAAmB,KAAK3C,SAA5B,EAAuC;UACnCT,YAAY,GAAGF,mBAAmB,CAAC,IAAD,EAAOtB,SAAP,CAAlC;QACH,CAFD,MAEO,IAAI,OAAO4E,mBAAP,KAA+B,QAAnC,EAA6C;UAChD,IAAIA,mBAAmB,GAAG,CAAtB,IAA2BA,mBAAmB,IAAI,KAAKX,eAA3D,EAA4E;YACxE,MAAMzB,oBAAoB,EAA1B;UACH;;UAEDhB,YAAY,GAAGG,wBAAwB,CAAC,IAAD,EAAO3B,SAAP,EAAkB4E,mBAAlB,CAAvC;QACH,CANM,MAMA;UACH,IAAI7E,MAAM,KAAKkC,SAAX,KAAyBlC,MAAM,GAAG,CAAT,IAAcA,MAAM,IAAI,KAAKkE,eAAtD,CAAJ,EAA4E;YACxE,MAAMzB,oBAAoB,EAA1B;UACH;;UAED,IAAIrE,WAAW,CAACyG,mBAAD,CAAX,IAAoC7D,KAAK,KAAKkB,SAA9C,KAA4DlB,KAAK,GAAG,CAAR,IAAaA,KAAK,IAAI6D,mBAAmB,CAACZ,cAAtG,CAAJ,EAA2H;YACvH,MAAMxB,oBAAoB,EAA1B;UACH;;UAEDhB,YAAY,GAAGK,6BAA6B,CAAC,IAAD,EAAO7B,SAAP,EAAkB4E,mBAAlB,EAAuC7E,MAAvC,EAA+CgB,KAA/C,CAA5C;;UAEA,IAAIS,YAAY,CAACqD,MAAb,KAAwB,CAA5B,EAA+B;YAC3B,MAAMpC,wBAAwB,EAA9B;UACH;QACJ,CA7Ba,CA+Bd;;;QA/Bc,4CAgCYjB,YAhCZ;QAAA;;QAAA;UAgCd,uDAAwC;YAAA,IAA7B1B,WAA6B;YACpC,IAAM0E,MAAM,GAAG5B,YAAY,CAAC,CAAC,IAAD,CAAD,EAAS9C,WAAT,CAA3B;YAEAJ,sBAAsB,CAAC8E,MAAD,EAAS7B,qBAAT,CAAtB;UACH;QApCa;UAAA;QAAA;UAAA;QAAA;MAqCjB;IA5NL;;IAAA;EAAA,EACYE,sBADZ;AA8NH,CAhPM","names":["AUDIO_NODE_STORE","EVENT_LISTENERS","isAudioNode","isAudioNodeOutputConnection","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioParam","connectNativeAudioNodeToNativeAudioNode","deleteActiveInputConnection","deleteActiveInputConnectionToAudioParam","deleteEventListenerOfAudioNode","deletePassiveInputConnectionToAudioNode","deletePassiveInputConnectionToAudioParam","disconnectNativeAudioNodeFromNativeAudioNode","getAudioNodeConnections","getAudioParamConnections","getEventListenersOfAudioNode","getNativeAudioNode","getNativeAudioParam","insertElementInSet","isActiveAudioNode","isPartOfACycle","isPassiveAudioNode","setInternalStateToActive","setInternalStateToPassiveWhenNecessary","testAudioNodeDisconnectMethodSupport","visitEachAudioNodeOnce","wrapAudioNodeDisconnectMethod","addConnectionToAudioParamOfAudioContext","source","destination","output","isOffline","activeInputs","passiveInputs","outputs","eventListeners","eventListener","isActive","nativeAudioNode","nativeAudioParam","partialConnection","connect","disconnect","outputConnection","add","deleteInputConnectionOfAudioNode","input","activeInputConnection","passiveInputConnection","deleteInputConnectionOfAudioParam","deleteInputsOfAudioNode","listener","deleteInputsOfAudioParam","deleteAnyConnection","audioNodeConnectionsOfSource","destinations","push","clear","deleteConnectionAtOutput","delete","deleteConnectionToDestination","Array","from","filter","undefined","map","createAudioNodeConstructor","addAudioNodeConnections","addConnectionToAudioNode","cacheTestResult","createIncrementCycleCounter","createIndexSizeError","createInvalidAccessError","createNotSupportedError","decrementCycleCounter","detectCycles","eventTargetConstructor","getNativeContext","isNativeAudioContext","isNativeAudioNode","isNativeAudioParam","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","context","audioNodeRenderer","_context","_nativeAudioNode","nativeContext","set","Set","state","channelCount","value","channelCountMode","channelInterpretation","numberOfInputs","numberOfOutputs","nativeDestinationAudioNode","connection","isPassive","err","code","isNewConnectionToAudioNode","cycles","name","maxValue","isNewConnectionToAudioParam","destinationOrOutput","length"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\standardized-audio-context\\src\\factories\\audio-node-constructor.ts"],"sourcesContent":["import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nimport {\n    IAudioNode,\n    IAudioNodeRenderer,\n    IAudioParam,\n    IMinimalOfflineAudioContext,\n    INativeAudioNodeFaker,\n    IOfflineAudioContext\n} from '../interfaces';\nimport {\n    TAudioNodeConstructorFactory,\n    TChannelCountMode,\n    TChannelInterpretation,\n    TContext,\n    TInternalStateEventListener,\n    TNativeAudioNode,\n    TNativeAudioParam\n} from '../types';\n\nconst addConnectionToAudioParamOfAudioContext = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number,\n    isOffline: boolean\n): boolean => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n\n    const eventListener: TInternalStateEventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        } else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n\n    if (\n        insertElementInSet(\n            outputs,\n            [destination, output],\n            (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output,\n            true\n        )\n    ) {\n        eventListeners.add(eventListener);\n\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        } else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\nconst deleteInputConnectionOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n        return [passiveInputConnection[2], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n        return [passiveInputConnection[1], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\n\nconst deleteInputsOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioParam,\n    output: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\n\nconst deleteAnyConnection = <T extends TContext>(source: IAudioNode<T>, isOffline: boolean): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        } else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n\n        destinations.push(outputConnection[0]);\n    }\n\n    audioNodeConnectionsOfSource.outputs.clear();\n\n    return destinations;\n};\n\nconst deleteConnectionAtOutput = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    output: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n\n    return destinations;\n};\n\nconst deleteConnectionToDestination = <T extends TContext, U extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<U> | IAudioParam,\n    output?: number,\n    input?: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter(\n            (outputConnection) =>\n                outputConnection[0] === destination &&\n                (output === undefined || outputConnection[1] === output) &&\n                (input === undefined || outputConnection[2] === input)\n        )\n        .map((outputConnection) => {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n\n            return outputConnection[0];\n        });\n};\n\nexport const createAudioNodeConstructor: TAudioNodeConstructorFactory = (\n    addAudioNodeConnections,\n    addConnectionToAudioNode,\n    cacheTestResult,\n    createIncrementCycleCounter,\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    decrementCycleCounter,\n    detectCycles,\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n) => {\n    return class AudioNode<T extends TContext, EventMap extends Record<string, Event> = {}>\n        extends eventTargetConstructor<EventMap>\n        implements IAudioNode<T, EventMap>\n    {\n        private _context: T;\n\n        private _nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode;\n\n        constructor(\n            context: T,\n            isActive: boolean,\n            nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n            audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null\n        ) {\n            super(nativeAudioNode);\n\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n\n            const nativeContext = getNativeContext(context);\n\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (\n                isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n                    })\n            ) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioNode.channelCount;\n        }\n\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n\n        get channelInterpretation(): TChannelInterpretation {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n\n        get context(): T {\n            return this._context;\n        }\n\n        get numberOfInputs(): number {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n\n        get numberOfOutputs(): number {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n\n        public connect<U extends TContext, V extends IAudioNode<U>>(destinationNode: V, output?: number, input?: number): V;\n        public connect(destinationParam: IAudioParam, output?: number): void;\n        // tslint:disable-next-line:invalid-void\n        public connect<U extends TContext, V extends IAudioNode<U>>(destination: V | IAudioParam, output = 0, input = 0): void | V {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(\n                        this._nativeAudioNode,\n                        nativeDestinationAudioNode,\n                        output,\n                        input\n                    );\n\n                    const isPassive = isPassiveAudioNode(this);\n\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                } catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n\n                    throw err;\n                }\n\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(\n                    this,\n                    <IAudioNode<TContext>>destination,\n                    output,\n                    input,\n                    isOffline\n                );\n\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], <IAudioNode<T>>(<unknown>destination));\n\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n\n                return destination;\n            }\n\n            const nativeAudioParam = getNativeAudioParam(destination);\n\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if ((<TNativeAudioParam & { name: string }>nativeAudioParam).name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n                throw createNotSupportedError();\n            }\n\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            } catch (err) {\n                // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n\n        public disconnect(output?: number): void;\n        public disconnect<U extends TContext>(destinationNode: IAudioNode<U>, output?: number, input?: number): void;\n        public disconnect(destinationParam: IAudioParam, output?: number): void;\n        public disconnect<U extends TContext>(\n            destinationOrOutput?: number | IAudioNode<U> | IAudioParam,\n            output?: number,\n            input?: number\n        ): void {\n            let destinations: (IAudioNode<T> | IAudioParam)[];\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            } else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            } else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}