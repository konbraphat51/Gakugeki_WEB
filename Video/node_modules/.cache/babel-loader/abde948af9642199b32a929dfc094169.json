{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { PORT_MAP } from './port-map';\nexport var extendBrokerImplementation = function extendBrokerImplementation(partialBrokerImplementation) {\n  return _objectSpread(_objectSpread({}, partialBrokerImplementation), {}, {\n    connect: function connect(_ref) {\n      var call = _ref.call;\n      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _MessageChannel, port1, port2, portId;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _MessageChannel = new MessageChannel(), port1 = _MessageChannel.port1, port2 = _MessageChannel.port2;\n                _context.next = 3;\n                return call('connect', {\n                  port: port1\n                }, [port1]);\n\n              case 3:\n                portId = _context.sent;\n                PORT_MAP.set(port2, portId);\n                return _context.abrupt(\"return\", port2);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    },\n    disconnect: function disconnect(_ref3) {\n      var call = _ref3.call;\n      return /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(port) {\n          var portId;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  portId = PORT_MAP.get(port);\n\n                  if (!(portId === undefined)) {\n                    _context2.next = 3;\n                    break;\n                  }\n\n                  throw new Error('The given port is not connected.');\n\n                case 3:\n                  _context2.next = 5;\n                  return call('disconnect', {\n                    portId: portId\n                  });\n\n                case 5:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function (_x) {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n    },\n    isSupported: function isSupported(_ref5) {\n      var call = _ref5.call;\n      return function () {\n        return call('isSupported');\n      };\n    }\n  });\n};","map":{"version":3,"mappings":";;;AAGA,SAASA,QAAT,QAAyB,YAAzB;AAEA,OAAO,IAAMC,0BAA0B,GAAG,SAA7BA,0BAA6B,CACtCC,2BADsC;EAAA,uCAI/BA,2BAJ+B;IAKlCC,OAAO,EAAE,uBAAa;MAAA,IAAVC,IAAU,QAAVA,IAAU;MAClB,+EAAO;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAAA,kBACsB,IAAIC,cAAJ,EADtB,EACKC,KADL,mBACKA,KADL,EACYC,KADZ,mBACYA,KADZ;gBAAA;gBAAA,OAG0BH,IAAI,CAAC,SAAD,EAAY;kBAAEI,IAAI,EAAEF;gBAAR,CAAZ,EAA6B,CAACA,KAAD,CAA7B,CAH9B;;cAAA;gBAGGG,MAHH;gBAKHT,QAAQ,CAACU,GAAT,CAAaH,KAAb,EAAoBE,MAApB;gBALG,iCAOIF,KAPJ;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAAP;IASH,CAfiC;IAgBlCI,UAAU,EAAE,2BAAa;MAAA,IAAVP,IAAU,SAAVA,IAAU;MACrB;QAAA,uEAAO,kBAAOI,IAAP;UAAA;UAAA;YAAA;cAAA;gBAAA;kBACGC,MADH,GACYT,QAAQ,CAACY,GAAT,CAAaJ,IAAb,CADZ;;kBAAA,MAGCC,MAAM,KAAKI,SAHZ;oBAAA;oBAAA;kBAAA;;kBAAA,MAIO,IAAIC,KAAJ,CAAU,kCAAV,CAJP;;gBAAA;kBAAA;kBAAA,OAOGV,IAAI,CAAC,YAAD,EAAe;oBAAEK,MAAM,EAANA;kBAAF,CAAf,CAPP;;gBAAA;gBAAA;kBAAA;cAAA;YAAA;UAAA;QAAA,CAAP;;QAAA;UAAA;QAAA;MAAA;IASH,CA1BiC;IA2BlCM,WAAW,EAAE,4BAAa;MAAA,IAAVX,IAAU,SAAVA,IAAU;MACtB,OAAO;QAAA,OAAMA,IAAI,CAAC,aAAD,CAAV;MAAA,CAAP;IACH;EA7BiC;AAAA,CAAnC","names":["PORT_MAP","extendBrokerImplementation","partialBrokerImplementation","connect","call","MessageChannel","port1","port2","port","portId","set","disconnect","get","undefined","Error","isSupported"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\broker-factory\\src\\helpers\\extend-broker-implementation.ts"],"sourcesContent":["import { IWorkerDefinition } from 'worker-factory';\nimport { IBrokerDefinition, IDefaultBrokerDefinition } from '../interfaces';\nimport { TBrokerImplementation } from '../types';\nimport { PORT_MAP } from './port-map';\n\nexport const extendBrokerImplementation = <T extends IBrokerDefinition, U extends IWorkerDefinition>(\n    partialBrokerImplementation: TBrokerImplementation<T, U>\n): TBrokerImplementation<T & IDefaultBrokerDefinition, U> =>\n    <TBrokerImplementation<T & IDefaultBrokerDefinition, U>>{\n        ...partialBrokerImplementation,\n        connect: ({ call }) => {\n            return async (): Promise<MessagePort> => {\n                const { port1, port2 } = new MessageChannel();\n\n                const portId = <number>await call('connect', { port: port1 }, [port1]);\n\n                PORT_MAP.set(port2, portId);\n\n                return port2;\n            };\n        },\n        disconnect: ({ call }) => {\n            return async (port: MessagePort): Promise<void> => {\n                const portId = PORT_MAP.get(port);\n\n                if (portId === undefined) {\n                    throw new Error('The given port is not connected.');\n                }\n\n                await call('disconnect', { portId });\n            };\n        },\n        isSupported: ({ call }) => {\n            return () => call('isSupported');\n        }\n    };\n"]},"metadata":{},"sourceType":"module"}