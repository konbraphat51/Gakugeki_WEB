{"ast":null,"code":"import _objectSpread from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nvar DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport var createMinimalOfflineAudioContextConstructor = function createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, _startRendering) {\n  return /*#__PURE__*/function (_minimalBaseAudioCont) {\n    _inherits(MinimalOfflineAudioContext, _minimalBaseAudioCont);\n\n    var _super = _createSuper(MinimalOfflineAudioContext);\n\n    function MinimalOfflineAudioContext(options) {\n      var _this;\n\n      _classCallCheck(this, MinimalOfflineAudioContext);\n\n      var _DEFAULT_OPTIONS$opti = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options),\n          length = _DEFAULT_OPTIONS$opti.length,\n          numberOfChannels = _DEFAULT_OPTIONS$opti.numberOfChannels,\n          sampleRate = _DEFAULT_OPTIONS$opti.sampleRate;\n\n      var nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate); // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n\n      if (!cacheTestResult(testPromiseSupport, function () {\n        return testPromiseSupport(nativeOfflineAudioContext);\n      })) {\n        nativeOfflineAudioContext.addEventListener('statechange', function () {\n          var i = 0;\n\n          var delayStateChangeEvent = function delayStateChangeEvent(event) {\n            if (_this._state === 'running') {\n              if (i > 0) {\n                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                event.stopImmediatePropagation();\n\n                _this._waitForThePromiseToSettle(event);\n              } else {\n                i += 1;\n              }\n            }\n          };\n\n          return delayStateChangeEvent;\n        }());\n      }\n\n      _this = _super.call(this, nativeOfflineAudioContext, numberOfChannels);\n      _this._length = length;\n      _this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n      _this._state = null;\n      return _this;\n    }\n\n    _createClass(MinimalOfflineAudioContext, [{\n      key: \"length\",\n      get: function get() {\n        // Bug #17: Safari does not yet expose the length.\n        if (this._nativeOfflineAudioContext.length === undefined) {\n          return this._length;\n        }\n\n        return this._nativeOfflineAudioContext.length;\n      }\n    }, {\n      key: \"state\",\n      get: function get() {\n        return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n      }\n    }, {\n      key: \"startRendering\",\n      value: function startRendering() {\n        var _this2 = this;\n\n        /*\n         * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n         * the state of the nativeOfflineAudioContext might no transition to running immediately.\n         */\n        if (this._state === 'running') {\n          return Promise.reject(createInvalidStateError());\n        }\n\n        this._state = 'running';\n        return _startRendering(this.destination, this._nativeOfflineAudioContext).finally(function () {\n          _this2._state = null;\n          deactivateAudioGraph(_this2);\n        });\n      }\n    }, {\n      key: \"_waitForThePromiseToSettle\",\n      value: function _waitForThePromiseToSettle(event) {\n        var _this3 = this;\n\n        if (this._state === null) {\n          this._nativeOfflineAudioContext.dispatchEvent(event);\n        } else {\n          setTimeout(function () {\n            return _this3._waitForThePromiseToSettle(event);\n          });\n        }\n      }\n    }]);\n\n    return MinimalOfflineAudioContext;\n  }(minimalBaseAudioContextConstructor);\n};","map":{"version":3,"mappings":"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","names":["deactivateAudioGraph","testPromiseSupport","DEFAULT_OPTIONS","numberOfChannels","createMinimalOfflineAudioContextConstructor","cacheTestResult","createInvalidStateError","createNativeOfflineAudioContext","minimalBaseAudioContextConstructor","startRendering","options","length","sampleRate","nativeOfflineAudioContext","addEventListener","i","delayStateChangeEvent","event","_state","removeEventListener","stopImmediatePropagation","_waitForThePromiseToSettle","_length","_nativeOfflineAudioContext","undefined","state","Promise","reject","destination","finally","dispatchEvent","setTimeout"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\standardized-audio-context\\src\\factories\\minimal-offline-audio-context-constructor.ts"],"sourcesContent":["import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IMinimalOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TMinimalOfflineAudioContextConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createMinimalOfflineAudioContextConstructor: TMinimalOfflineAudioContextConstructorFactory = (\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    minimalBaseAudioContextConstructor,\n    startRendering\n) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor<IMinimalOfflineAudioContext>\n        implements IMinimalOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}