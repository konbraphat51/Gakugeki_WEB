{"ast":null,"code":"import _objectSpread from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nvar DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport var createAudioBufferConstructor = function createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) {\n  var nativeOfflineAudioContext = null;\n  return /*#__PURE__*/function (_Symbol$hasInstance) {\n    function AudioBuffer(options) {\n      _classCallCheck(this, AudioBuffer);\n\n      if (nativeOfflineAudioContextConstructor === null) {\n        throw new Error('Missing the native OfflineAudioContext constructor.');\n      }\n\n      var _DEFAULT_OPTIONS$opti = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options),\n          length = _DEFAULT_OPTIONS$opti.length,\n          numberOfChannels = _DEFAULT_OPTIONS$opti.numberOfChannels,\n          sampleRate = _DEFAULT_OPTIONS$opti.sampleRate;\n\n      if (nativeOfflineAudioContext === null) {\n        nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n      }\n      /*\n       * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n       * factory function. But since Firefox also supports the constructor everything should be fine.\n       */\n\n\n      var audioBuffer = nativeAudioBufferConstructor !== null && cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor({\n        length: length,\n        numberOfChannels: numberOfChannels,\n        sampleRate: sampleRate\n      }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate); // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n\n      if (audioBuffer.numberOfChannels === 0) {\n        throw createNotSupportedError();\n      } // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n      // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n\n\n      if (typeof audioBuffer.copyFromChannel !== 'function') {\n        wrapAudioBufferCopyChannelMethods(audioBuffer);\n        wrapAudioBufferGetChannelDataMethod(audioBuffer); // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n      } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, function () {\n        return testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer);\n      })) {\n        wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n      }\n\n      audioBufferStore.add(audioBuffer);\n      /*\n       * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n       * (Offline)AudioContexts.\n       */\n\n      return audioBuffer;\n    }\n\n    _createClass(AudioBuffer, null, [{\n      key: _Symbol$hasInstance,\n      value: function value(instance) {\n        return instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore.has(instance);\n      }\n    }]);\n\n    return AudioBuffer;\n  }(Symbol.hasInstance);\n};","map":{"version":3,"mappings":";;;AAAA,SAASA,mDAAT,QAAoE,yEAApE;AACA,SAASC,mCAAT,QAAoD,sDAApD;AAIA,IAAMC,eAAe,GAAG;EACpBC,gBAAgB,EAAE;AADE,CAAxB;AAIA,OAAO,IAAMC,4BAA4B,GAAmC,SAA/DA,4BAA+D,CACxEC,gBADwE,EAExEC,eAFwE,EAGxEC,uBAHwE,EAIxEC,4BAJwE,EAKxEC,oCALwE,EAMxEC,uCANwE,EAOxEC,iCAPwE,EAQxEC,4CARwE,EASxE;EACA,IAAIC,yBAAyB,GAAsC,IAAnE;EAEA;IAsBI,qBAAYC,OAAZ,EAAwC;MAAA;;MACpC,IAAIL,oCAAoC,KAAK,IAA7C,EAAmD;QAC/C,MAAM,IAAIM,KAAJ,CAAU,qDAAV,CAAN;MACH;;MAED,4DAAsDb,eAAtD,GAA0EY,OAA1E;MAAA,IAAQE,MAAR,yBAAQA,MAAR;MAAA,IAAgBb,gBAAhB,yBAAgBA,gBAAhB;MAAA,IAAkCc,UAAlC,yBAAkCA,UAAlC;;MAEA,IAAIJ,yBAAyB,KAAK,IAAlC,EAAwC;QACpCA,yBAAyB,GAAG,IAAIJ,oCAAJ,CAAyC,CAAzC,EAA4C,CAA5C,EAA+C,KAA/C,CAA5B;MACH;MAED;;;;;;MAIA,IAAMS,WAAW,GACbV,4BAA4B,KAAK,IAAjC,IACAF,eAAe,CAACI,uCAAD,EAA0CA,uCAA1C,CADf,GAEM,IAAIF,4BAAJ,CAAiC;QAAEQ,MAAM,EAANA,MAAF;QAAUb,gBAAgB,EAAhBA,gBAAV;QAA4Bc,UAAU,EAAVA;MAA5B,CAAjC,CAFN,GAGMJ,yBAAyB,CAACM,YAA1B,CAAuChB,gBAAvC,EAAyDa,MAAzD,EAAiEC,UAAjE,CAJV,CAfoC,CAqBpC;;MACA,IAAIC,WAAW,CAACf,gBAAZ,KAAiC,CAArC,EAAwC;QACpC,MAAMI,uBAAuB,EAA7B;MACH,CAxBmC,CA0BpC;MACA;;;MACA,IAAI,OAAOW,WAAW,CAACE,eAAnB,KAAuC,UAA3C,EAAuD;QACnDT,iCAAiC,CAACO,WAAD,CAAjC;QACAjB,mCAAmC,CAACiB,WAAD,CAAnC,CAFmD,CAGnD;MACH,CAJD,MAIO,IACH,CAACZ,eAAe,CAACN,mDAAD,EAAsD;QAAA,OAClEA,mDAAmD,CAACkB,WAAD,CADe;MAAA,CAAtD,CADb,EAIL;QACEN,4CAA4C,CAACM,WAAD,CAA5C;MACH;;MAEDb,gBAAgB,CAACgB,GAAjB,CAAqBH,WAArB;MAEA;;;;;MAIA,OAAOA,WAAP;IACH;;IArEL;MAAA;MAAA,OAuEW,eAA4BI,QAA5B,EAA6C;QAChD,OACKA,QAAQ,KAAK,IAAb,IAAqB,OAAOA,QAAP,KAAoB,QAAzC,IAAqDC,MAAM,CAACC,cAAP,CAAsBF,QAAtB,MAAoCG,WAAW,CAACC,SAAtG,IACArB,gBAAgB,CAACsB,GAAjB,CAA0BL,QAA1B,CAFJ;MAIH;IA5EL;;IAAA;EAAA,EAuEmBM,MAAM,CAACC,WAvE1B;AA8EH,CA1FM","names":["testAudioBufferCopyChannelMethodsOutOfBoundsSupport","wrapAudioBufferGetChannelDataMethod","DEFAULT_OPTIONS","numberOfChannels","createAudioBufferConstructor","audioBufferStore","cacheTestResult","createNotSupportedError","nativeAudioBufferConstructor","nativeOfflineAudioContextConstructor","testNativeAudioBufferConstructorSupport","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","nativeOfflineAudioContext","options","Error","length","sampleRate","audioBuffer","createBuffer","copyFromChannel","add","instance","Object","getPrototypeOf","AudioBuffer","prototype","has","Symbol","hasInstance"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\standardized-audio-context\\src\\factories\\audio-buffer-constructor.ts"],"sourcesContent":["import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { IAudioBuffer, IAudioBufferOptions } from '../interfaces';\nimport { TAudioBufferConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createAudioBufferConstructor: TAudioBufferConstructorFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    testNativeAudioBufferConstructorSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    let nativeOfflineAudioContext: null | TNativeOfflineAudioContext = null;\n\n    return class AudioBuffer implements IAudioBuffer {\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyFromChannel!: (destination: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyToChannel!: (source: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public duration!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public getChannelData!: (channel: number) => Float32Array;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public length!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public numberOfChannels!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public sampleRate!: number;\n\n        constructor(options: IAudioBufferOptions) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer =\n                nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)\n                    ? new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate })\n                    : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            } else if (\n                !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                    testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                )\n            ) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n\n            audioBufferStore.add(audioBuffer);\n\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype) ||\n                audioBufferStore.has(<any>instance)\n            );\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}