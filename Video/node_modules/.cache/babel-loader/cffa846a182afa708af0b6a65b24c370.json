{"ast":null,"code":"import _slicedToArray from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _regeneratorRuntime from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport { AudioBuffer, AudioBufferSourceNode, AudioWorkletNode, MediaStreamAudioSourceNode, MinimalAudioContext, addAudioWorkletModule } from 'standardized-audio-context';\nvar ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.'; // @todo This should live in a separate file.\n\nvar createPromisedAudioNodesEncoderIdAndPort = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(audioBuffer, audioContext, channelCount, mediaStream, mimeType) {\n    var _yield$instantiate, encoderId, port, audioBufferSourceNode, mediaStreamAudioSourceNode, recorderAudioWorkletNode;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return instantiate(mimeType, audioContext.sampleRate);\n\n          case 2:\n            _yield$instantiate = _context.sent;\n            encoderId = _yield$instantiate.encoderId;\n            port = _yield$instantiate.port;\n\n            if (!(AudioWorkletNode === undefined)) {\n              _context.next = 7;\n              break;\n            }\n\n            throw new Error(ERROR_MESSAGE);\n\n          case 7:\n            audioBufferSourceNode = new AudioBufferSourceNode(audioContext, {\n              buffer: audioBuffer\n            });\n            mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, {\n              mediaStream: mediaStream\n            });\n            recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, {\n              channelCount: channelCount\n            });\n            return _context.abrupt(\"return\", {\n              audioBufferSourceNode: audioBufferSourceNode,\n              encoderId: encoderId,\n              mediaStreamAudioSourceNode: mediaStreamAudioSourceNode,\n              port: port,\n              recorderAudioWorkletNode: recorderAudioWorkletNode\n            });\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function createPromisedAudioNodesEncoderIdAndPort(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport var createWebAudioMediaRecorderFactory = function createWebAudioMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) {\n  return function (eventTarget, mediaStream, mimeType) {\n    var _a;\n\n    var sampleRate = (_a = mediaStream.getAudioTracks()[0]) === null || _a === void 0 ? void 0 : _a.getSettings().sampleRate;\n    var audioContext = new MinimalAudioContext({\n      latencyHint: 'playback',\n      sampleRate: sampleRate\n    });\n    var length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n    var audioBuffer = new AudioBuffer({\n      length: length,\n      sampleRate: audioContext.sampleRate\n    });\n    var bufferedArrayBuffers = [];\n    var promisedAudioWorkletModule = addRecorderAudioWorkletModule(function (url) {\n      if (addAudioWorkletModule === undefined) {\n        throw new Error(ERROR_MESSAGE);\n      }\n\n      return addAudioWorkletModule(audioContext, url);\n    });\n    var abortRecording = null;\n    var intervalId = null;\n    var promisedAudioNodesAndEncoderId = null;\n    var promisedPartialRecording = null;\n    var isAudioContextRunning = true;\n\n    var dispatchDataAvailableEvent = function dispatchDataAvailableEvent(arrayBuffers) {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n\n    var requestNextPartialRecording = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(encoderId, timeslice) {\n        var arrayBuffers;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return encode(encoderId, timeslice);\n\n              case 2:\n                arrayBuffers = _context2.sent;\n\n                if (promisedAudioNodesAndEncoderId === null) {\n                  bufferedArrayBuffers.push.apply(bufferedArrayBuffers, _toConsumableArray(arrayBuffers));\n                } else {\n                  dispatchDataAvailableEvent(arrayBuffers);\n                  promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                }\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function requestNextPartialRecording(_x6, _x7) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    var _resume = function resume() {\n      isAudioContextRunning = true;\n      return audioContext.resume();\n    };\n\n    var stop = function stop() {\n      if (promisedAudioNodesAndEncoderId === null) {\n        return;\n      }\n\n      if (abortRecording !== null) {\n        mediaStream.removeEventListener('addtrack', abortRecording);\n        mediaStream.removeEventListener('removetrack', abortRecording);\n      }\n\n      if (intervalId !== null) {\n        clearTimeout(intervalId);\n      }\n\n      promisedAudioNodesAndEncoderId.then( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref3) {\n          var encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode, arrayBuffers;\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  encoderId = _ref3.encoderId, mediaStreamAudioSourceNode = _ref3.mediaStreamAudioSourceNode, recorderAudioWorkletNode = _ref3.recorderAudioWorkletNode;\n\n                  if (promisedPartialRecording !== null) {\n                    promisedPartialRecording.catch(function () {\n                      /* @todo Only catch the errors caused by a duplicate call to encode. */\n                    });\n                    promisedPartialRecording = null;\n                  }\n\n                  _context3.next = 4;\n                  return recorderAudioWorkletNode.stop();\n\n                case 4:\n                  mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n                  _context3.next = 7;\n                  return encode(encoderId, null);\n\n                case 7:\n                  arrayBuffers = _context3.sent;\n\n                  if (!(promisedAudioNodesAndEncoderId === null)) {\n                    _context3.next = 11;\n                    break;\n                  }\n\n                  _context3.next = 11;\n                  return suspend();\n\n                case 11:\n                  dispatchDataAvailableEvent([].concat(bufferedArrayBuffers, _toConsumableArray(arrayBuffers)));\n                  bufferedArrayBuffers.length = 0;\n                  eventTarget.dispatchEvent(new Event('stop'));\n\n                case 14:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        return function (_x8) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n      promisedAudioNodesAndEncoderId = null;\n    };\n\n    var suspend = function suspend() {\n      isAudioContextRunning = false;\n      return audioContext.suspend();\n    };\n\n    suspend();\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n\n      get state() {\n        return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n      },\n\n      pause: function pause() {\n        if (promisedAudioNodesAndEncoderId === null) {\n          throw createInvalidStateError();\n        }\n\n        if (isAudioContextRunning) {\n          suspend();\n          eventTarget.dispatchEvent(new Event('pause'));\n        }\n      },\n      resume: function resume() {\n        if (promisedAudioNodesAndEncoderId === null) {\n          throw createInvalidStateError();\n        }\n\n        if (!isAudioContextRunning) {\n          _resume();\n\n          eventTarget.dispatchEvent(new Event('resume'));\n        }\n      },\n      start: function start(timeslice) {\n        var _a;\n\n        if (promisedAudioNodesAndEncoderId !== null) {\n          throw createInvalidStateError();\n        }\n\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        eventTarget.dispatchEvent(new Event('start'));\n        var audioTracks = mediaStream.getAudioTracks(); // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n\n        var channelCount = audioTracks.length === 0 ? 2 : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;\n        promisedAudioNodesAndEncoderId = Promise.all([_resume(), promisedAudioWorkletModule.then(function () {\n          return createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType);\n        })]).then( /*#__PURE__*/function () {\n          var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref5) {\n            var _ref7, _ref7$, audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode;\n\n            return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    _ref7 = _slicedToArray(_ref5, 2), _ref7$ = _ref7[1], audioBufferSourceNode = _ref7$.audioBufferSourceNode, encoderId = _ref7$.encoderId, mediaStreamAudioSourceNode = _ref7$.mediaStreamAudioSourceNode, port = _ref7$.port, recorderAudioWorkletNode = _ref7$.recorderAudioWorkletNode;\n                    mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n                    _context4.next = 4;\n                    return new Promise(function (resolve) {\n                      audioBufferSourceNode.onended = resolve;\n                      audioBufferSourceNode.connect(recorderAudioWorkletNode);\n                      audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n                    });\n\n                  case 4:\n                    audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n                    _context4.next = 7;\n                    return recorderAudioWorkletNode.record(port);\n\n                  case 7:\n                    if (timeslice !== undefined) {\n                      promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                    }\n\n                    return _context4.abrupt(\"return\", {\n                      encoderId: encoderId,\n                      mediaStreamAudioSourceNode: mediaStreamAudioSourceNode,\n                      recorderAudioWorkletNode: recorderAudioWorkletNode\n                    });\n\n                  case 9:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4);\n          }));\n\n          return function (_x9) {\n            return _ref6.apply(this, arguments);\n          };\n        }());\n        var tracks = mediaStream.getTracks();\n\n        abortRecording = function abortRecording() {\n          stop();\n          eventTarget.dispatchEvent(new ErrorEvent('error', {\n            error: createInvalidModificationError()\n          }));\n        };\n\n        mediaStream.addEventListener('addtrack', abortRecording);\n        mediaStream.addEventListener('removetrack', abortRecording);\n        intervalId = setInterval(function () {\n          var currentTracks = mediaStream.getTracks();\n\n          if ((currentTracks.length !== tracks.length || currentTracks.some(function (track, index) {\n            return track !== tracks[index];\n          })) && abortRecording !== null) {\n            abortRecording();\n          }\n        }, 1000);\n      },\n      stop: stop\n    };\n  };\n};","map":{"version":3,"mappings":"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","names":["encode","instantiate","addRecorderAudioWorkletModule","createRecorderAudioWorkletNode","AudioBuffer","AudioBufferSourceNode","AudioWorkletNode","MediaStreamAudioSourceNode","MinimalAudioContext","addAudioWorkletModule","ERROR_MESSAGE","createPromisedAudioNodesEncoderIdAndPort","audioBuffer","audioContext","channelCount","mediaStream","mimeType","sampleRate","encoderId","port","undefined","Error","audioBufferSourceNode","buffer","mediaStreamAudioSourceNode","recorderAudioWorkletNode","createWebAudioMediaRecorderFactory","createBlobEvent","createInvalidModificationError","createInvalidStateError","createNotSupportedError","eventTarget","getAudioTracks","_a","getSettings","latencyHint","length","Math","max","ceil","baseLatency","bufferedArrayBuffers","promisedAudioWorkletModule","url","abortRecording","intervalId","promisedAudioNodesAndEncoderId","promisedPartialRecording","isAudioContextRunning","dispatchDataAvailableEvent","arrayBuffers","dispatchEvent","data","Blob","type","requestNextPartialRecording","timeslice","push","resume","stop","removeEventListener","clearTimeout","then","catch","disconnect","suspend","Event","state","pause","start","getVideoTracks","audioTracks","Promise","all","connect","resolve","onended","currentTime","record","tracks","getTracks","ErrorEvent","error","addEventListener","setInterval","currentTracks","some","track","index"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\extendable-media-recorder\\src\\factories\\web-audio-media-recorder.ts"],"sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport {\n    AudioBuffer,\n    AudioBufferSourceNode,\n    AudioWorkletNode,\n    IAudioBuffer,\n    IMinimalAudioContext,\n    MediaStreamAudioSourceNode,\n    MinimalAudioContext,\n    addAudioWorkletModule\n} from 'standardized-audio-context';\nimport { IAudioNodesAndEncoderId } from '../interfaces';\nimport { TRecordingState, TWebAudioMediaRecorderFactoryFactory } from '../types';\n\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.';\n\n// @todo This should live in a separate file.\nconst createPromisedAudioNodesEncoderIdAndPort = async (\n    audioBuffer: IAudioBuffer,\n    audioContext: IMinimalAudioContext,\n    channelCount: number,\n    mediaStream: MediaStream,\n    mimeType: string\n) => {\n    const { encoderId, port } = await instantiate(mimeType, audioContext.sampleRate);\n\n    if (AudioWorkletNode === undefined) {\n        throw new Error(ERROR_MESSAGE);\n    }\n\n    const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, { buffer: audioBuffer });\n    const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, { mediaStream });\n    const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, { channelCount });\n\n    return { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode };\n};\n\nexport const createWebAudioMediaRecorderFactory: TWebAudioMediaRecorderFactoryFactory = (\n    createBlobEvent,\n    createInvalidModificationError,\n    createInvalidStateError,\n    createNotSupportedError\n) => {\n    return (eventTarget, mediaStream, mimeType) => {\n        const sampleRate = mediaStream.getAudioTracks()[0]?.getSettings().sampleRate;\n        const audioContext = new MinimalAudioContext({ latencyHint: 'playback', sampleRate });\n        const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n        const audioBuffer = new AudioBuffer({ length, sampleRate: audioContext.sampleRate });\n        const bufferedArrayBuffers: ArrayBuffer[] = [];\n        const promisedAudioWorkletModule = addRecorderAudioWorkletModule((url: string) => {\n            if (addAudioWorkletModule === undefined) {\n                throw new Error(ERROR_MESSAGE);\n            }\n\n            return addAudioWorkletModule(audioContext, url);\n        });\n\n        let abortRecording: null | (() => void) = null;\n        let intervalId: null | number = null;\n        let promisedAudioNodesAndEncoderId: null | Promise<IAudioNodesAndEncoderId> = null;\n        let promisedPartialRecording: null | Promise<void> = null;\n        let isAudioContextRunning = true;\n\n        const dispatchDataAvailableEvent = (arrayBuffers: ArrayBuffer[]): void => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n\n        const requestNextPartialRecording = async (encoderId: number, timeslice: number): Promise<void> => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n\n            if (promisedAudioNodesAndEncoderId === null) {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            } else {\n                dispatchDataAvailableEvent(arrayBuffers);\n\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n\n        const resume = (): Promise<void> => {\n            isAudioContextRunning = true;\n\n            return audioContext.resume();\n        };\n\n        const stop = (): void => {\n            if (promisedAudioNodesAndEncoderId === null) {\n                return;\n            }\n\n            if (abortRecording !== null) {\n                mediaStream.removeEventListener('addtrack', abortRecording);\n                mediaStream.removeEventListener('removetrack', abortRecording);\n            }\n\n            if (intervalId !== null) {\n                clearTimeout(intervalId);\n            }\n\n            promisedAudioNodesAndEncoderId.then(async ({ encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode }) => {\n                if (promisedPartialRecording !== null) {\n                    promisedPartialRecording.catch(() => {\n                        /* @todo Only catch the errors caused by a duplicate call to encode. */\n                    });\n                    promisedPartialRecording = null;\n                }\n\n                await recorderAudioWorkletNode.stop();\n\n                mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n\n                const arrayBuffers = await encode(encoderId, null);\n\n                if (promisedAudioNodesAndEncoderId === null) {\n                    await suspend();\n                }\n\n                dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n\n                bufferedArrayBuffers.length = 0;\n\n                eventTarget.dispatchEvent(new Event('stop'));\n            });\n\n            promisedAudioNodesAndEncoderId = null;\n        };\n\n        const suspend = (): Promise<void> => {\n            isAudioContextRunning = false;\n\n            return audioContext.suspend();\n        };\n\n        suspend();\n\n        return {\n            get mimeType(): string {\n                return mimeType;\n            },\n\n            get state(): TRecordingState {\n                return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n            },\n\n            pause(): void {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n\n                if (isAudioContextRunning) {\n                    suspend();\n                    eventTarget.dispatchEvent(new Event('pause'));\n                }\n            },\n\n            resume(): void {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n\n                if (!isAudioContextRunning) {\n                    resume();\n                    eventTarget.dispatchEvent(new Event('resume'));\n                }\n            },\n\n            start(timeslice?: number): void {\n                if (promisedAudioNodesAndEncoderId !== null) {\n                    throw createInvalidStateError();\n                }\n\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n\n                eventTarget.dispatchEvent(new Event('start'));\n\n                const audioTracks = mediaStream.getAudioTracks();\n                // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n                const channelCount =\n                    audioTracks.length === 0\n                        ? 2\n                        : (<MediaTrackSettings & { channelCount?: number }>audioTracks[0].getSettings()).channelCount ?? 2;\n\n                promisedAudioNodesAndEncoderId = Promise.all([\n                    resume(),\n                    promisedAudioWorkletModule.then(() =>\n                        createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType)\n                    )\n                ]).then(async ([, { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode }]) => {\n                    mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n\n                    await new Promise((resolve) => {\n                        audioBufferSourceNode.onended = resolve;\n                        audioBufferSourceNode.connect(recorderAudioWorkletNode);\n                        audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n                    });\n\n                    audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n\n                    await recorderAudioWorkletNode.record(port);\n\n                    if (timeslice !== undefined) {\n                        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                    }\n\n                    return { encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode };\n                });\n\n                const tracks = mediaStream.getTracks();\n\n                abortRecording = () => {\n                    stop();\n                    eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n                };\n\n                mediaStream.addEventListener('addtrack', abortRecording);\n                mediaStream.addEventListener('removetrack', abortRecording);\n\n                intervalId = setInterval(() => {\n                    const currentTracks = mediaStream.getTracks();\n\n                    if (\n                        (currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) &&\n                        abortRecording !== null\n                    ) {\n                        abortRecording();\n                    }\n                }, 1000);\n            },\n\n            stop\n        };\n    };\n};\n"]},"metadata":{},"sourceType":"module"}