{"ast":null,"code":"import _objectSpread from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar DEFAULT_OPTIONS = {\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  curve: null,\n  oversample: 'none'\n};\nexport var createWaveShaperNodeConstructor = function createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime) {\n  return /*#__PURE__*/function (_audioNodeConstructor) {\n    _inherits(WaveShaperNode, _audioNodeConstructor);\n\n    var _super = _createSuper(WaveShaperNode);\n\n    function WaveShaperNode(context, options) {\n      var _this;\n\n      _classCallCheck(this, WaveShaperNode);\n\n      var nativeContext = getNativeContext(context);\n\n      var mergedOptions = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n\n      var nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n      var isOffline = isNativeOfflineAudioContext(nativeContext);\n      var waveShaperNodeRenderer = isOffline ? createWaveShaperNodeRenderer() : null; // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n\n      _this = _super.call(this, context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n      _this._isCurveNullified = false;\n      _this._nativeWaveShaperNode = nativeWaveShaperNode; // @todo Determine a meaningful tail-time instead of just using one second.\n\n      setAudioNodeTailTime(_assertThisInitialized(_this), 1);\n      return _this;\n    }\n\n    _createClass(WaveShaperNode, [{\n      key: \"curve\",\n      get: function get() {\n        if (this._isCurveNullified) {\n          return null;\n        }\n\n        return this._nativeWaveShaperNode.curve;\n      },\n      set: function set(value) {\n        // Bug #103: Safari does not allow to set the curve to null.\n        if (value === null) {\n          this._isCurveNullified = true;\n          this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n        } else {\n          // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n          // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n          if (value.length < 2) {\n            throw createInvalidStateError();\n          }\n\n          this._isCurveNullified = false;\n          this._nativeWaveShaperNode.curve = value;\n        }\n      }\n    }, {\n      key: \"oversample\",\n      get: function get() {\n        return this._nativeWaveShaperNode.oversample;\n      },\n      set: function set(value) {\n        this._nativeWaveShaperNode.oversample = value;\n      }\n    }]);\n\n    return WaveShaperNode;\n  }(audioNodeConstructor);\n};","map":{"version":3,"mappings":";;;;;;AAGA,IAAMA,eAAe,GAAG;EACpBC,YAAY,EAAE,CADM;EAEpBC,gBAAgB,EAAE,KAFE;EAGpBC,qBAAqB,EAAE,UAHH;EAIpBC,KAAK,EAAE,IAJa;EAKpBC,UAAU,EAAE;AALQ,CAAxB;AAQA,OAAO,IAAMC,+BAA+B,GAAsC,SAArEA,+BAAqE,CAC9EC,oBAD8E,EAE9EC,uBAF8E,EAG9EC,0BAH8E,EAI9EC,4BAJ8E,EAK9EC,gBAL8E,EAM9EC,2BAN8E,EAO9EC,oBAP8E,EAQ9E;EACA;IAAA;;IAAA;;IAKI,wBAAYC,OAAZ,EAAwBC,OAAxB,EAA6D;MAAA;;MAAA;;MACzD,IAAMC,aAAa,GAAGL,gBAAgB,CAACG,OAAD,CAAtC;;MACA,IAAMG,aAAa,mCAAQjB,eAAR,GAA4Be,OAA5B,CAAnB;;MACA,IAAMG,oBAAoB,GAAGT,0BAA0B,CAACO,aAAD,EAAgBC,aAAhB,CAAvD;MACA,IAAME,SAAS,GAAGP,2BAA2B,CAACI,aAAD,CAA7C;MACA,IAAMI,sBAAsB,GAAiCD,SAAS,GAAGT,4BAA4B,EAA/B,GAAoC,IAA1G,CALyD,CAOzD;;MACA,0BAAMI,OAAN,EAAe,IAAf,EAAqBI,oBAArB,EAA2CE,sBAA3C;MAEA,MAAKC,iBAAL,GAAyB,KAAzB;MACA,MAAKC,qBAAL,GAA6BJ,oBAA7B,CAXyD,CAazD;;MACAL,oBAAoB,gCAAO,CAAP,CAApB;MAdyD;IAe5D;;IApBL;MAAA;MAAA,KAsBI,eAAS;QACL,IAAI,KAAKQ,iBAAT,EAA4B;UACxB,OAAO,IAAP;QACH;;QAED,OAAO,KAAKC,qBAAL,CAA2BlB,KAAlC;MACH,CA5BL;MAAA,KA8BI,aAAUmB,KAAV,EAAe;QACX;QACA,IAAIA,KAAK,KAAK,IAAd,EAAoB;UAChB,KAAKF,iBAAL,GAAyB,IAAzB;UACA,KAAKC,qBAAL,CAA2BlB,KAA3B,GAAmC,IAAIoB,YAAJ,CAAiB,CAAC,CAAD,EAAI,CAAJ,CAAjB,CAAnC;QACH,CAHD,MAGO;UACH;UACA;UACA,IAAID,KAAK,CAACE,MAAN,GAAe,CAAnB,EAAsB;YAClB,MAAMjB,uBAAuB,EAA7B;UACH;;UAED,KAAKa,iBAAL,GAAyB,KAAzB;UACA,KAAKC,qBAAL,CAA2BlB,KAA3B,GAAmCmB,KAAnC;QACH;MACJ;IA7CL;MAAA;MAAA,KA+CI,eAAc;QACV,OAAO,KAAKD,qBAAL,CAA2BjB,UAAlC;MACH,CAjDL;MAAA,KAmDI,aAAekB,KAAf,EAAoB;QAChB,KAAKD,qBAAL,CAA2BjB,UAA3B,GAAwCkB,KAAxC;MACH;IArDL;;IAAA;EAAA,EAAwDhB,oBAAxD;AAuDH,CAhEM","names":["DEFAULT_OPTIONS","channelCount","channelCountMode","channelInterpretation","curve","oversample","createWaveShaperNodeConstructor","audioNodeConstructor","createInvalidStateError","createNativeWaveShaperNode","createWaveShaperNodeRenderer","getNativeContext","isNativeOfflineAudioContext","setAudioNodeTailTime","context","options","nativeContext","mergedOptions","nativeWaveShaperNode","isOffline","waveShaperNodeRenderer","_isCurveNullified","_nativeWaveShaperNode","value","Float32Array","length"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\standardized-audio-context\\src\\factories\\wave-shaper-node-constructor.ts"],"sourcesContent":["import { IWaveShaperNode, IWaveShaperOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TNativeWaveShaperNode, TOverSampleType, TWaveShaperNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n} as const;\n\nexport const createWaveShaperNodeConstructor: TWaveShaperNodeConstructorFactory = (\n    audioNodeConstructor,\n    createInvalidStateError,\n    createNativeWaveShaperNode,\n    createWaveShaperNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class WaveShaperNode<T extends TContext> extends audioNodeConstructor<T> implements IWaveShaperNode<T> {\n        private _isCurveNullified: boolean;\n\n        private _nativeWaveShaperNode: TNativeWaveShaperNode;\n\n        constructor(context: T, options?: Partial<IWaveShaperOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createWaveShaperNodeRenderer() : null);\n\n            // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n            super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get curve(): null | Float32Array {\n            if (this._isCurveNullified) {\n                return null;\n            }\n\n            return this._nativeWaveShaperNode.curve;\n        }\n\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            } else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n\n        get oversample(): TOverSampleType {\n            return this._nativeWaveShaperNode.oversample;\n        }\n\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}