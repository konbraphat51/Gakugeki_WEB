{"ast":null,"code":"export var createReadElementContent = function createReadElementContent(readVariableSizeInteger) {\n  return function (dataView, offset, type) {\n    var channelCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    var lengthAndValue = readVariableSizeInteger(dataView, offset);\n\n    if (lengthAndValue === null) {\n      return lengthAndValue;\n    }\n\n    var length = lengthAndValue.length,\n        value = lengthAndValue.value;\n\n    if (type === 'master') {\n      return {\n        content: null,\n        length: length\n      };\n    }\n\n    if (offset + length + value > dataView.byteLength) {\n      return null;\n    }\n\n    if (type === 'binary') {\n      var numberOfSamples = (value / Float32Array.BYTES_PER_ELEMENT - 1) / channelCount;\n      var content = Array.from({\n        length: channelCount\n      }, function () {\n        return new Float32Array(numberOfSamples);\n      });\n\n      for (var i = 0; i < numberOfSamples; i += 1) {\n        var elementOffset = i * channelCount + 1;\n\n        for (var j = 0; j < channelCount; j += 1) {\n          content[j][i] = dataView.getFloat32(offset + length + (elementOffset + j) * Float32Array.BYTES_PER_ELEMENT, true);\n        }\n      }\n\n      return {\n        content: content,\n        length: length + value\n      };\n    }\n\n    return {\n      content: null,\n      length: length + value\n    };\n  };\n};","map":{"version":3,"mappings":"AAEA,OAAO,IAAMA,wBAAwB,GAA+B,SAAvDA,wBAAuD,CAACC,uBAAD,EAA4B;EAC5F,OAAO,UAACC,QAAD,EAAWC,MAAX,EAAmBC,IAAnB,EAA6C;IAAA,IAApBC,YAAoB,uEAAL,CAAK;IAChD,IAAMC,cAAc,GAAGL,uBAAuB,CAACC,QAAD,EAAWC,MAAX,CAA9C;;IAEA,IAAIG,cAAc,KAAK,IAAvB,EAA6B;MACzB,OAAOA,cAAP;IACH;;IAED,IAAQC,MAAR,GAA0BD,cAA1B,CAAQC,MAAR;IAAA,IAAgBC,KAAhB,GAA0BF,cAA1B,CAAgBE,KAAhB;;IAEA,IAAIJ,IAAI,KAAK,QAAb,EAAuB;MACnB,OAAO;QAAEK,OAAO,EAAE,IAAX;QAAiBF,MAAM,EAANA;MAAjB,CAAP;IACH;;IAED,IAAIJ,MAAM,GAAGI,MAAT,GAAkBC,KAAlB,GAA0BN,QAAQ,CAACQ,UAAvC,EAAmD;MAC/C,OAAO,IAAP;IACH;;IAED,IAAIN,IAAI,KAAK,QAAb,EAAuB;MACnB,IAAMO,eAAe,GAAG,CAACH,KAAK,GAAGI,YAAY,CAACC,iBAArB,GAAyC,CAA1C,IAA+CR,YAAvE;MACA,IAAMI,OAAO,GAAGK,KAAK,CAACC,IAAN,CAAW;QAAER,MAAM,EAAEF;MAAV,CAAX,EAAqC;QAAA,OAAM,IAAIO,YAAJ,CAAiBD,eAAjB,CAAN;MAAA,CAArC,CAAhB;;MAEA,KAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,eAApB,EAAqCK,CAAC,IAAI,CAA1C,EAA6C;QACzC,IAAMC,aAAa,GAAGD,CAAC,GAAGX,YAAJ,GAAmB,CAAzC;;QAEA,KAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,YAApB,EAAkCa,CAAC,IAAI,CAAvC,EAA0C;UACtCT,OAAO,CAACS,CAAD,CAAP,CAAWF,CAAX,IAAgBd,QAAQ,CAACiB,UAAT,CAAoBhB,MAAM,GAAGI,MAAT,GAAkB,CAACU,aAAa,GAAGC,CAAjB,IAAsBN,YAAY,CAACC,iBAAzE,EAA4F,IAA5F,CAAhB;QACH;MACJ;;MAED,OAAO;QAAEJ,OAAO,EAAPA,OAAF;QAAWF,MAAM,EAAEA,MAAM,GAAGC;MAA5B,CAAP;IACH;;IAED,OAAO;MAAEC,OAAO,EAAE,IAAX;MAAiBF,MAAM,EAAEA,MAAM,GAAGC;IAAlC,CAAP;EACH,CAjCD;AAkCH,CAnCM","names":["createReadElementContent","readVariableSizeInteger","dataView","offset","type","channelCount","lengthAndValue","length","value","content","byteLength","numberOfSamples","Float32Array","BYTES_PER_ELEMENT","Array","from","i","elementOffset","j","getFloat32"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\extendable-media-recorder\\src\\factories\\read-element-content.ts"],"sourcesContent":["import { TReadElementContentFactory } from '../types';\n\nexport const createReadElementContent: TReadElementContentFactory = (readVariableSizeInteger) => {\n    return (dataView, offset, type, channelCount = 2) => {\n        const lengthAndValue = readVariableSizeInteger(dataView, offset);\n\n        if (lengthAndValue === null) {\n            return lengthAndValue;\n        }\n\n        const { length, value } = lengthAndValue;\n\n        if (type === 'master') {\n            return { content: null, length };\n        }\n\n        if (offset + length + value > dataView.byteLength) {\n            return null;\n        }\n\n        if (type === 'binary') {\n            const numberOfSamples = (value / Float32Array.BYTES_PER_ELEMENT - 1) / channelCount;\n            const content = Array.from({ length: channelCount }, () => new Float32Array(numberOfSamples));\n\n            for (let i = 0; i < numberOfSamples; i += 1) {\n                const elementOffset = i * channelCount + 1;\n\n                for (let j = 0; j < channelCount; j += 1) {\n                    content[j][i] = dataView.getFloat32(offset + length + (elementOffset + j) * Float32Array.BYTES_PER_ELEMENT, true);\n                }\n            }\n\n            return { content, length: length + value };\n        }\n\n        return { content: null, length: length + value };\n    };\n};\n"]},"metadata":{},"sourceType":"module"}