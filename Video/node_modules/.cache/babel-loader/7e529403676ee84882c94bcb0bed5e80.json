{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nexport var createWebmPcmMediaRecorderFactory = function createWebmPcmMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk, readVariableSizeInteger) {\n  return function (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) {\n    var audioTracks = mediaStream.getAudioTracks();\n    var bufferedArrayBuffers = []; // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n\n    var channelCount = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().channelCount;\n    var nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, {\n      mimeType: 'audio/webm;codecs=pcm'\n    });\n    var sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n    var promisedPartialRecording = null;\n\n    var stopRecording = function stopRecording() {}; // tslint:disable-line:no-empty\n\n\n    var dispatchDataAvailableEvent = function dispatchDataAvailableEvent(arrayBuffers) {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n\n    var requestNextPartialRecording = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(encoderId, timeslice) {\n        var arrayBuffers;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return encode(encoderId, timeslice);\n\n              case 2:\n                arrayBuffers = _context.sent;\n\n                if (nativeMediaRecorder.state === 'inactive') {\n                  bufferedArrayBuffers.push.apply(bufferedArrayBuffers, _toConsumableArray(arrayBuffers));\n                } else {\n                  dispatchDataAvailableEvent(arrayBuffers);\n                  promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                }\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function requestNextPartialRecording(_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    var stop = function stop() {\n      if (nativeMediaRecorder.state === 'inactive') {\n        return;\n      }\n\n      if (promisedPartialRecording !== null) {\n        promisedPartialRecording.catch(function () {\n          /* @todo Only catch the errors caused by a duplicate call to encode. */\n        });\n        promisedPartialRecording = null;\n      }\n\n      stopRecording();\n\n      stopRecording = function stopRecording() {}; // tslint:disable-line:no-empty\n\n\n      nativeMediaRecorder.stop();\n    };\n\n    nativeMediaRecorder.addEventListener('error', function () {\n      stop(); // Bug #3 & #4: Chrome throws an error event without any error.\n\n      eventTarget.dispatchEvent(new ErrorEvent('error', {\n        error: createInvalidModificationError()\n      }));\n    });\n    nativeMediaRecorder.addEventListener('start', function () {\n      return eventTarget.dispatchEvent(new Event('start'));\n    });\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n\n      get state() {\n        return nativeMediaRecorder.state;\n      },\n\n      pause: function pause() {\n        return nativeMediaRecorder.pause();\n      },\n      resume: function resume() {\n        return nativeMediaRecorder.resume();\n      },\n      start: function start(timeslice) {\n        /*\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n         * codec.\n         */\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        if (nativeMediaRecorder.state === 'inactive') {\n          if (sampleRate === undefined) {\n            throw new Error('The sampleRate is not defined.');\n          }\n\n          var isRecording = false;\n          var isStopped = false; // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n\n          var pendingInvocations = 0;\n          var promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);\n\n          stopRecording = function stopRecording() {\n            isStopped = true;\n          };\n\n          var removeEventListener = on(nativeMediaRecorder, 'dataavailable')(function (_ref2) {\n            var data = _ref2.data;\n            pendingInvocations += 1;\n            promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then( /*#__PURE__*/function () {\n              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {\n                var _ref3$dataView, dataView, _ref3$elementType, elementType, encoderId, port, arrayBuffer, currentDataView, lengthAndValue, value, _decodeWebMChunk, currentElementType, offset, contents, remainingDataView;\n\n                return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _ref3$dataView = _ref3.dataView, dataView = _ref3$dataView === void 0 ? null : _ref3$dataView, _ref3$elementType = _ref3.elementType, elementType = _ref3$elementType === void 0 ? null : _ref3$elementType, encoderId = _ref3.encoderId, port = _ref3.port;\n                        _context2.next = 3;\n                        return data.arrayBuffer();\n\n                      case 3:\n                        arrayBuffer = _context2.sent;\n                        pendingInvocations -= 1;\n                        currentDataView = dataView === null ? new MultiBufferDataView([arrayBuffer]) : new MultiBufferDataView([].concat(_toConsumableArray(dataView.buffers), [arrayBuffer]), dataView.byteOffset);\n\n                        if (!(!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped)) {\n                          _context2.next = 14;\n                          break;\n                        }\n\n                        lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n\n                        if (!(lengthAndValue === null)) {\n                          _context2.next = 10;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\", {\n                          dataView: currentDataView,\n                          elementType: elementType,\n                          encoderId: encoderId,\n                          port: port\n                        });\n\n                      case 10:\n                        value = lengthAndValue.value;\n\n                        if (!(value !== 172351395)) {\n                          _context2.next = 13;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\", {\n                          dataView: dataView,\n                          elementType: elementType,\n                          encoderId: encoderId,\n                          port: port\n                        });\n\n                      case 13:\n                        isRecording = true;\n\n                      case 14:\n                        _decodeWebMChunk = decodeWebMChunk(currentDataView, elementType, channelCount), currentElementType = _decodeWebMChunk.currentElementType, offset = _decodeWebMChunk.offset, contents = _decodeWebMChunk.contents;\n                        remainingDataView = offset < currentDataView.byteLength ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset) : null;\n                        contents.forEach(function (content) {\n                          return port.postMessage(content, content.map(function (_ref5) {\n                            var buffer = _ref5.buffer;\n                            return buffer;\n                          }));\n                        });\n\n                        if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                          encode(encoderId, null).then(function (arrayBuffers) {\n                            dispatchDataAvailableEvent([].concat(bufferedArrayBuffers, _toConsumableArray(arrayBuffers)));\n                            bufferedArrayBuffers.length = 0;\n                            eventTarget.dispatchEvent(new Event('stop'));\n                          });\n                          port.postMessage([]);\n                          port.close();\n                          removeEventListener();\n                        }\n\n                        return _context2.abrupt(\"return\", {\n                          dataView: remainingDataView,\n                          elementType: currentElementType,\n                          encoderId: encoderId,\n                          port: port\n                        });\n\n                      case 19:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n\n              return function (_x3) {\n                return _ref4.apply(this, arguments);\n              };\n            }());\n          });\n\n          if (timeslice !== undefined) {\n            promisedDataViewElementTypeEncoderIdAndPort.then(function (_ref6) {\n              var encoderId = _ref6.encoderId;\n              return promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            });\n          }\n        }\n\n        nativeMediaRecorder.start(100);\n      },\n      stop: stop\n    };\n  };\n};","map":{"version":3,"mappings":"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","names":["encode","instantiate","MultiBufferDataView","on","createWebmPcmMediaRecorderFactory","createBlobEvent","createInvalidModificationError","createNotSupportedError","decodeWebMChunk","readVariableSizeInteger","eventTarget","nativeMediaRecorderConstructor","mediaStream","mimeType","audioTracks","getAudioTracks","bufferedArrayBuffers","channelCount","length","undefined","getSettings","nativeMediaRecorder","sampleRate","promisedPartialRecording","stopRecording","dispatchDataAvailableEvent","arrayBuffers","dispatchEvent","data","Blob","type","requestNextPartialRecording","encoderId","timeslice","state","push","stop","catch","addEventListener","ErrorEvent","error","Event","pause","resume","start","getVideoTracks","Error","isRecording","isStopped","pendingInvocations","promisedDataViewElementTypeEncoderIdAndPort","removeEventListener","then","dataView","elementType","port","arrayBuffer","currentDataView","buffers","byteOffset","lengthAndValue","value","currentElementType","offset","contents","remainingDataView","byteLength","forEach","content","postMessage","map","buffer","close"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\extendable-media-recorder\\src\\factories\\webm-pcm-media-recorder.ts"],"sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nimport { TPromisedDataViewElementTypeEncoderIdAndPort, TRecordingState, TWebmPcmMediaRecorderFactoryFactory } from '../types';\n\nexport const createWebmPcmMediaRecorderFactory: TWebmPcmMediaRecorderFactoryFactory = (\n    createBlobEvent,\n    createInvalidModificationError,\n    createNotSupportedError,\n    decodeWebMChunk,\n    readVariableSizeInteger\n) => {\n    return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n        const audioTracks = mediaStream.getAudioTracks();\n        const bufferedArrayBuffers: ArrayBuffer[] = [];\n        // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n        const channelCount =\n            audioTracks.length === 0\n                ? undefined\n                : (<MediaTrackSettings & { channelCount?: number }>audioTracks[0].getSettings()).channelCount;\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, { mimeType: 'audio/webm;codecs=pcm' });\n        const sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n\n        let promisedPartialRecording: null | Promise<void> = null;\n        let stopRecording = () => {}; // tslint:disable-line:no-empty\n\n        const dispatchDataAvailableEvent = (arrayBuffers: ArrayBuffer[]): void => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n\n        const requestNextPartialRecording = async (encoderId: number, timeslice: number): Promise<void> => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n\n            if (nativeMediaRecorder.state === 'inactive') {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            } else {\n                dispatchDataAvailableEvent(arrayBuffers);\n\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n\n        const stop = (): void => {\n            if (nativeMediaRecorder.state === 'inactive') {\n                return;\n            }\n\n            if (promisedPartialRecording !== null) {\n                promisedPartialRecording.catch(() => {\n                    /* @todo Only catch the errors caused by a duplicate call to encode. */\n                });\n                promisedPartialRecording = null;\n            }\n\n            stopRecording();\n            stopRecording = () => {}; // tslint:disable-line:no-empty\n\n            nativeMediaRecorder.stop();\n        };\n\n        nativeMediaRecorder.addEventListener('error', () => {\n            stop();\n            // Bug #3 & #4: Chrome throws an error event without any error.\n            eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n        });\n        nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n\n        return {\n            get mimeType(): string {\n                return mimeType;\n            },\n\n            get state(): TRecordingState {\n                return nativeMediaRecorder.state;\n            },\n\n            pause(): void {\n                return nativeMediaRecorder.pause();\n            },\n\n            resume(): void {\n                return nativeMediaRecorder.resume();\n            },\n\n            start(timeslice?: number): void {\n                /*\n                 * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n                 * codec.\n                 */\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n\n                if (nativeMediaRecorder.state === 'inactive') {\n                    if (sampleRate === undefined) {\n                        throw new Error('The sampleRate is not defined.');\n                    }\n\n                    let isRecording = false;\n                    let isStopped = false;\n                    // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n                    let pendingInvocations = 0;\n                    let promisedDataViewElementTypeEncoderIdAndPort: TPromisedDataViewElementTypeEncoderIdAndPort = instantiate(\n                        mimeType,\n                        sampleRate\n                    );\n\n                    stopRecording = () => {\n                        isStopped = true;\n                    };\n\n                    const removeEventListener = on(\n                        nativeMediaRecorder,\n                        'dataavailable'\n                    )(({ data }) => {\n                        pendingInvocations += 1;\n\n                        promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(\n                            async ({ dataView = null, elementType = null, encoderId, port }) => {\n                                const arrayBuffer = await data.arrayBuffer();\n\n                                pendingInvocations -= 1;\n\n                                const currentDataView =\n                                    dataView === null\n                                        ? new MultiBufferDataView([arrayBuffer])\n                                        : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n\n                                if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                                    const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n\n                                    if (lengthAndValue === null) {\n                                        return { dataView: currentDataView, elementType, encoderId, port };\n                                    }\n\n                                    const { value } = lengthAndValue;\n\n                                    if (value !== 172351395) {\n                                        return { dataView, elementType, encoderId, port };\n                                    }\n\n                                    isRecording = true;\n                                }\n\n                                const { currentElementType, offset, contents } = decodeWebMChunk(\n                                    currentDataView,\n                                    elementType,\n                                    channelCount\n                                );\n                                const remainingDataView =\n                                    offset < currentDataView.byteLength\n                                        ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset)\n                                        : null;\n\n                                contents.forEach((content) =>\n                                    port.postMessage(\n                                        content,\n                                        content.map(({ buffer }) => buffer)\n                                    )\n                                );\n\n                                if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                                    encode(encoderId, null).then((arrayBuffers) => {\n                                        dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n\n                                        bufferedArrayBuffers.length = 0;\n\n                                        eventTarget.dispatchEvent(new Event('stop'));\n                                    });\n\n                                    port.postMessage([]);\n                                    port.close();\n\n                                    removeEventListener();\n                                }\n\n                                return { dataView: remainingDataView, elementType: currentElementType, encoderId, port };\n                            }\n                        );\n                    });\n\n                    if (timeslice !== undefined) {\n                        promisedDataViewElementTypeEncoderIdAndPort.then(\n                            ({ encoderId }) => (promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice))\n                        );\n                    }\n                }\n\n                nativeMediaRecorder.start(100);\n            },\n\n            stop\n        };\n    };\n};\n"]},"metadata":{},"sourceType":"module"}