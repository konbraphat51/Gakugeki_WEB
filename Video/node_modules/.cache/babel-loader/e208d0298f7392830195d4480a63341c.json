{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { createBroker } from 'broker-factory';\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\n\nexport * from './interfaces/index';\nexport * from './types/index';\nexport var wrap = createBroker({\n  characterize: function characterize(_ref) {\n    var call = _ref.call;\n    return function () {\n      return call('characterize');\n    };\n  },\n  encode: function encode(_ref2) {\n    var call = _ref2.call;\n    return function (recordingId, timeslice) {\n      return call('encode', {\n        recordingId: recordingId,\n        timeslice: timeslice\n      });\n    };\n  },\n  record: function record(_ref3) {\n    var call = _ref3.call;\n    return /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(recordingId, sampleRate, typedArrays) {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return call('record', {\n                  recordingId: recordingId,\n                  sampleRate: sampleRate,\n                  typedArrays: typedArrays\n                }, typedArrays.map(function (_ref5) {\n                  var buffer = _ref5.buffer;\n                  return buffer;\n                }));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x, _x2, _x3) {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n  }\n});\nexport var load = function load(url) {\n  var worker = new Worker(url);\n  return wrap(worker);\n};","map":{"version":3,"mappings":";;AAAA,SAASA,YAAT,QAA6B,gBAA7B;AAKA;;;;;AAIA,cAAc,oBAAd;AACA,cAAc,eAAd;AAEA,OAAO,IAAMC,IAAI,GAAoDD,YAAY,CAG/E;EACEE,YAAY,EAAE,4BAAa;IAAA,IAAVC,IAAU,QAAVA,IAAU;IACvB,OAAO;MAAA,OAAMA,IAAI,CAAC,cAAD,CAAV;IAAA,CAAP;EACH,CAHH;EAIEC,MAAM,EAAE,uBAAa;IAAA,IAAVD,IAAU,SAAVA,IAAU;IACjB,OAAO,UAACE,WAAD,EAAcC,SAAd,EAA2B;MAC9B,OAAOH,IAAI,CAAC,QAAD,EAAW;QAAEE,WAAW,EAAXA,WAAF;QAAeC,SAAS,EAATA;MAAf,CAAX,CAAX;IACH,CAFD;EAGH,CARH;EASEC,MAAM,EAAE,uBAAa;IAAA,IAAVJ,IAAU,SAAVA,IAAU;IACjB;MAAA,uEAAO,iBAAOE,WAAP,EAAoBG,UAApB,EAAgCC,WAAhC;QAAA;UAAA;YAAA;cAAA;gBAAA;gBAAA,OACGN,IAAI,CACN,QADM,EAEN;kBAAEE,WAAW,EAAXA,WAAF;kBAAeG,UAAU,EAAVA,UAAf;kBAA2BC,WAAW,EAAXA;gBAA3B,CAFM,EAGNA,WAAW,CAACC,GAAZ,CAAgB;kBAAA,IAAGC,MAAH,SAAGA,MAAH;kBAAA,OAAgBA,MAAhB;gBAAA,CAAhB,CAHM,CADP;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAAP;;MAAA;QAAA;MAAA;IAAA;EAOH;AAjBH,CAH+E,CAA1E;AAuBP,OAAO,IAAMC,IAAI,GAAmD,SAAvDA,IAAuD,CAACC,GAAD,EAAgB;EAChF,IAAMC,MAAM,GAAG,IAAIC,MAAJ,CAAWF,GAAX,CAAf;EAEA,OAAOZ,IAAI,CAACa,MAAD,CAAX;AACH,CAJM","names":["createBroker","wrap","characterize","call","encode","recordingId","timeslice","record","sampleRate","typedArrays","map","buffer","load","url","worker","Worker"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\extendable-media-recorder-wav-encoder-broker\\src\\module.ts"],"sourcesContent":["import { createBroker } from 'broker-factory';\nimport { TExtendableMediaRecorderWavEncoderWorkerDefinition } from 'extendable-media-recorder-wav-encoder-worker';\nimport { IExtendableMediaRecorderWavEncoderBrokerDefinition } from './interfaces';\nimport { TExtendableMediaRecorderWavEncoderBrokerLoader, TExtendableMediaRecorderWavEncoderBrokerWrapper } from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nexport const wrap: TExtendableMediaRecorderWavEncoderBrokerWrapper = createBroker<\n    IExtendableMediaRecorderWavEncoderBrokerDefinition,\n    TExtendableMediaRecorderWavEncoderWorkerDefinition\n>({\n    characterize: ({ call }) => {\n        return () => call('characterize');\n    },\n    encode: ({ call }) => {\n        return (recordingId, timeslice) => {\n            return call('encode', { recordingId, timeslice });\n        };\n    },\n    record: ({ call }) => {\n        return async (recordingId, sampleRate, typedArrays) => {\n            await call(\n                'record',\n                { recordingId, sampleRate, typedArrays },\n                typedArrays.map(({ buffer }) => buffer)\n            );\n        };\n    }\n});\n\nexport const load: TExtendableMediaRecorderWavEncoderBrokerLoader = (url: string) => {\n    const worker = new Worker(url);\n\n    return wrap(worker);\n};\n"]},"metadata":{},"sourceType":"module"}