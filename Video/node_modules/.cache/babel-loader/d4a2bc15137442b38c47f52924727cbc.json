{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _objectSpread from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nexport var createRecorderAudioWorkletNodeFactory = function createRecorderAudioWorkletNodeFactory(createListener, createPostMessage, on, validateState) {\n  return function (audioWorkletNodeConstructor, context) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var audioWorkletNode = new audioWorkletNodeConstructor(context, 'recorder-audio-worklet-processor', _objectSpread(_objectSpread({}, options), {}, {\n      channelCountMode: 'explicit',\n      numberOfInputs: 1,\n      numberOfOutputs: 0\n    }));\n    var ongoingRequests = new Map();\n    var postMessage = createPostMessage(ongoingRequests, audioWorkletNode.port);\n    var unsubscribe = on(audioWorkletNode.port, 'message')(createListener(ongoingRequests));\n    audioWorkletNode.port.start();\n    var state = 'inactive';\n    Object.defineProperties(audioWorkletNode, {\n      pause: {\n        get: function get() {\n          return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    validateState(['recording'], state);\n                    state = 'paused';\n                    return _context.abrupt(\"return\", postMessage({\n                      method: 'pause'\n                    }));\n\n                  case 3:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }));\n        }\n      },\n      port: {\n        get: function get() {\n          throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\n        }\n      },\n      record: {\n        get: function get() {\n          return /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(encoderPort) {\n              return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                while (1) {\n                  switch (_context2.prev = _context2.next) {\n                    case 0:\n                      validateState(['inactive'], state);\n                      state = 'recording';\n                      return _context2.abrupt(\"return\", postMessage({\n                        method: 'record',\n                        params: {\n                          encoderPort: encoderPort\n                        }\n                      }, [encoderPort]));\n\n                    case 3:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }\n              }, _callee2);\n            }));\n\n            return function (_x) {\n              return _ref2.apply(this, arguments);\n            };\n          }();\n        }\n      },\n      resume: {\n        get: function get() {\n          return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n            return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    validateState(['paused'], state);\n                    state = 'recording';\n                    return _context3.abrupt(\"return\", postMessage({\n                      method: 'resume'\n                    }));\n\n                  case 3:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            }, _callee3);\n          }));\n        }\n      },\n      stop: {\n        get: function get() {\n          return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n            return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    validateState(['paused', 'recording'], state);\n                    state = 'stopped';\n                    _context4.prev = 2;\n                    _context4.next = 5;\n                    return postMessage({\n                      method: 'stop'\n                    });\n\n                  case 5:\n                    _context4.prev = 5;\n                    unsubscribe();\n                    return _context4.finish(5);\n\n                  case 8:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4, null, [[2,, 5, 8]]);\n          }));\n        }\n      }\n    });\n    return audioWorkletNode;\n  };\n};","map":{"version":3,"mappings":";;;AAeA,OAAO,IAAMA,qCAAqC,GAAG,SAAxCA,qCAAwC,CACjDC,cADiD,EAEjDC,iBAFiD,EAGjDC,EAHiD,EAIjDC,aAJiD,EAKjD;EACA,OAAO,UACHC,2BADG,EAEHC,OAFG,EAIkF;IAAA,IADrFC,OACqF,uEAD1B,EAC0B;IAIrF,IAAMC,gBAAgB,GAAyB,IAAUH,2BAAV,CAAuCC,OAAvC,EAAgD,kCAAhD,kCACxCC,OADwC;MAE3CE,gBAAgB,EAAE,UAFyB;MAG3CC,cAAc,EAAE,CAH2B;MAI3CC,eAAe,EAAE;IAJ0B,GAA/C;IAMA,IAAMC,eAAe,GAAyD,IAAIC,GAAJ,EAA9E;IACA,IAAMC,WAAW,GAAGZ,iBAAiB,CAACU,eAAD,EAAkBJ,gBAAgB,CAACO,IAAnC,CAArC;IACA,IAAMC,WAAW,GAAGb,EAAE,CAACK,gBAAgB,CAACO,IAAlB,EAAwB,SAAxB,CAAF,CAAqCd,cAAc,CAACW,eAAD,CAAnD,CAApB;IAEAJ,gBAAgB,CAACO,IAAjB,CAAsBE,KAAtB;IAEA,IAAIC,KAAK,GAAW,UAApB;IAEAC,MAAM,CAACC,gBAAP,CAAwBZ,gBAAxB,EAA0C;MACtCa,KAAK,EAAE;QACHC,GADG,iBACA;UACC,+EAAO;YAAA;cAAA;gBAAA;kBAAA;oBACHlB,aAAa,CAAC,CAAC,WAAD,CAAD,EAAgBc,KAAhB,CAAb;oBAEAA,KAAK,GAAG,QAAR;oBAHG,iCAKIJ,WAAW,CAAC;sBACfS,MAAM,EAAE;oBADO,CAAD,CALf;;kBAAA;kBAAA;oBAAA;gBAAA;cAAA;YAAA;UAAA,CAAP;QASH;MAXE,CAD+B;MActCR,IAAI,EAAE;QACFO,GADE,iBACC;UACC,MAAM,IAAIE,KAAJ,CAAU,2DAAV,CAAN;QACH;MAHC,CAdgC;MAmBtCC,MAAM,EAAE;QACJH,GADI,iBACD;UACC;YAAA,uEAAO,kBAAOI,WAAP;cAAA;gBAAA;kBAAA;oBAAA;sBACHtB,aAAa,CAAC,CAAC,UAAD,CAAD,EAAec,KAAf,CAAb;sBAEAA,KAAK,GAAG,WAAR;sBAHG,kCAKIJ,WAAW,CACd;wBACIS,MAAM,EAAE,QADZ;wBAEII,MAAM,EAAE;0BAAED,WAAW,EAAXA;wBAAF;sBAFZ,CADc,EAKd,CAACA,WAAD,CALc,CALf;;oBAAA;oBAAA;sBAAA;kBAAA;gBAAA;cAAA;YAAA,CAAP;;YAAA;cAAA;YAAA;UAAA;QAaH;MAfG,CAnB8B;MAoCtCE,MAAM,EAAE;QACJN,GADI,iBACD;UACC,+EAAO;YAAA;cAAA;gBAAA;kBAAA;oBACHlB,aAAa,CAAC,CAAC,QAAD,CAAD,EAAac,KAAb,CAAb;oBAEAA,KAAK,GAAG,WAAR;oBAHG,kCAKIJ,WAAW,CAAC;sBACfS,MAAM,EAAE;oBADO,CAAD,CALf;;kBAAA;kBAAA;oBAAA;gBAAA;cAAA;YAAA;UAAA,CAAP;QASH;MAXG,CApC8B;MAiDtCM,IAAI,EAAE;QACFP,GADE,iBACC;UACC,+EAAO;YAAA;cAAA;gBAAA;kBAAA;oBACHlB,aAAa,CAAC,CAAC,QAAD,EAAW,WAAX,CAAD,EAA0Bc,KAA1B,CAAb;oBAEAA,KAAK,GAAG,SAAR;oBAHG;oBAAA;oBAAA,OAMOJ,WAAW,CAAC;sBAAES,MAAM,EAAE;oBAAV,CAAD,CANlB;;kBAAA;oBAAA;oBAQCP,WAAW;oBARZ;;kBAAA;kBAAA;oBAAA;gBAAA;cAAA;YAAA;UAAA,CAAP;QAWH;MAbC;IAjDgC,CAA1C;IAkEA,OAAqCR,gBAArC;EACH,CAzFD;AA0FH,CAhGM","names":["createRecorderAudioWorkletNodeFactory","createListener","createPostMessage","on","validateState","audioWorkletNodeConstructor","context","options","audioWorkletNode","channelCountMode","numberOfInputs","numberOfOutputs","ongoingRequests","Map","postMessage","port","unsubscribe","start","state","Object","defineProperties","pause","get","method","Error","record","encoderPort","params","resume","stop"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\recorder-audio-worklet\\src\\factories\\recorder-audio-worklet-node-factory.ts"],"sourcesContent":["import type {\n    IAudioWorkletNode,\n    TAudioWorkletNodeConstructor,\n    TContext,\n    TNativeAudioWorkletNode,\n    TNativeAudioWorkletNodeConstructor,\n    TNativeContext\n} from 'standardized-audio-context';\nimport type { on as onFunction } from 'subscribable-things';\nimport type { validateState as validateStateFunction } from '../functions/validate-state';\nimport { INativeRecorderAudioWorkletNode, IRecorderAudioWorkletNode } from '../interfaces';\nimport { TAnyRecorderAudioWorkletNodeOptions, TState } from '../types';\nimport type { createListener as createListenerFunction } from './listener';\nimport type { createPostMessageFactory } from './post-message-factory';\n\nexport const createRecorderAudioWorkletNodeFactory = (\n    createListener: typeof createListenerFunction,\n    createPostMessage: ReturnType<typeof createPostMessageFactory>,\n    on: typeof onFunction,\n    validateState: typeof validateStateFunction\n) => {\n    return <T extends TContext | TNativeContext>(\n        audioWorkletNodeConstructor: T extends TContext ? TAudioWorkletNodeConstructor : TNativeAudioWorkletNodeConstructor,\n        context: T,\n        options: Partial<TAnyRecorderAudioWorkletNodeOptions<T>> = {}\n    ): T extends TContext ? IRecorderAudioWorkletNode<T> : INativeRecorderAudioWorkletNode => {\n        type TAnyAudioWorkletNode = T extends TContext ? IAudioWorkletNode<T> : TNativeAudioWorkletNode;\n        type TAnyRecorderAudioWorkletNode = T extends TContext ? IRecorderAudioWorkletNode<T> : INativeRecorderAudioWorkletNode;\n\n        const audioWorkletNode: TAnyAudioWorkletNode = new (<any>audioWorkletNodeConstructor)(context, 'recorder-audio-worklet-processor', {\n            ...options,\n            channelCountMode: 'explicit',\n            numberOfInputs: 1,\n            numberOfOutputs: 0\n        });\n        const ongoingRequests: Map<number, { reject: Function; resolve: Function }> = new Map();\n        const postMessage = createPostMessage(ongoingRequests, audioWorkletNode.port);\n        const unsubscribe = on(audioWorkletNode.port, 'message')(createListener(ongoingRequests));\n\n        audioWorkletNode.port.start();\n\n        let state: TState = 'inactive';\n\n        Object.defineProperties(audioWorkletNode, {\n            pause: {\n                get(): TAnyRecorderAudioWorkletNode['pause'] {\n                    return async () => {\n                        validateState(['recording'], state);\n\n                        state = 'paused';\n\n                        return postMessage({\n                            method: 'pause'\n                        });\n                    };\n                }\n            },\n            port: {\n                get(): TAnyRecorderAudioWorkletNode['port'] {\n                    throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\n                }\n            },\n            record: {\n                get(): TAnyRecorderAudioWorkletNode['record'] {\n                    return async (encoderPort: MessagePort) => {\n                        validateState(['inactive'], state);\n\n                        state = 'recording';\n\n                        return postMessage(\n                            {\n                                method: 'record',\n                                params: { encoderPort }\n                            },\n                            [encoderPort]\n                        );\n                    };\n                }\n            },\n            resume: {\n                get(): TAnyRecorderAudioWorkletNode['resume'] {\n                    return async () => {\n                        validateState(['paused'], state);\n\n                        state = 'recording';\n\n                        return postMessage({\n                            method: 'resume'\n                        });\n                    };\n                }\n            },\n            stop: {\n                get(): TAnyRecorderAudioWorkletNode['stop'] {\n                    return async () => {\n                        validateState(['paused', 'recording'], state);\n\n                        state = 'stopped';\n\n                        try {\n                            await postMessage({ method: 'stop' });\n                        } finally {\n                            unsubscribe();\n                        }\n                    };\n                }\n            }\n        });\n\n        return <TAnyRecorderAudioWorkletNode>audioWorkletNode;\n    };\n};\n"]},"metadata":{},"sourceType":"module"}