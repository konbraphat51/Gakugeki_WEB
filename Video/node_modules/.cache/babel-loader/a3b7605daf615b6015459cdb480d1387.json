{"ast":null,"code":"import _classCallCheck from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _possibleConstructorReturn from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _assertThisInitialized from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nexport var createMediaRecorderConstructor = function createMediaRecorderConstructor(createNativeMediaRecorder, createNotSupportedError, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, eventTargetConstructor, nativeMediaRecorderConstructor) {\n  return /*#__PURE__*/function (_eventTargetConstruct) {\n    _inherits(MediaRecorder, _eventTargetConstruct);\n\n    var _super = _createSuper(MediaRecorder);\n\n    function MediaRecorder(stream) {\n      var _this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, MediaRecorder);\n\n      var mimeType = options.mimeType;\n\n      if (nativeMediaRecorderConstructor !== null && ( // Bug #10: Safari does not yet implement the isTypeSupported() method.\n      mimeType === undefined || nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported(mimeType))) {\n        var internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n        _this = _super.call(this, internalMediaRecorder);\n        _this._internalMediaRecorder = internalMediaRecorder;\n      } else if (mimeType !== undefined && encoderRegexes.some(function (regex) {\n        return regex.test(mimeType);\n      })) {\n        _this = _super.call(this); // Bug #10: Safari does not yet implement the isTypeSupported() method.\n\n        if (nativeMediaRecorderConstructor !== null && nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported('audio/webm;codecs=pcm')) {\n          _this._internalMediaRecorder = createWebmPcmMediaRecorder(_assertThisInitialized(_this), nativeMediaRecorderConstructor, stream, mimeType);\n        } else {\n          _this._internalMediaRecorder = createWebAudioMediaRecorder(_assertThisInitialized(_this), stream, mimeType);\n        }\n      } else {\n        // This is creating a native MediaRecorder just to provoke it to throw an error.\n        if (nativeMediaRecorderConstructor !== null) {\n          createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n        }\n\n        throw createNotSupportedError();\n      }\n\n      _this._ondataavailable = null;\n      _this._onerror = null;\n      _this._onpause = null;\n      _this._onresume = null;\n      _this._onstart = null;\n      _this._onstop = null;\n      return _possibleConstructorReturn(_this);\n    }\n\n    _createClass(MediaRecorder, [{\n      key: \"mimeType\",\n      get: function get() {\n        return this._internalMediaRecorder.mimeType;\n      }\n    }, {\n      key: \"ondataavailable\",\n      get: function get() {\n        return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];\n      },\n      set: function set(value) {\n        if (this._ondataavailable !== null) {\n          this.removeEventListener('dataavailable', this._ondataavailable[1]);\n        }\n\n        if (typeof value === 'function') {\n          var boundListener = value.bind(this);\n          this.addEventListener('dataavailable', boundListener);\n          this._ondataavailable = [value, boundListener];\n        } else {\n          this._ondataavailable = null;\n        }\n      }\n    }, {\n      key: \"onerror\",\n      get: function get() {\n        return this._onerror === null ? this._onerror : this._onerror[0];\n      },\n      set: function set(value) {\n        if (this._onerror !== null) {\n          this.removeEventListener('error', this._onerror[1]);\n        }\n\n        if (typeof value === 'function') {\n          var boundListener = value.bind(this);\n          this.addEventListener('error', boundListener);\n          this._onerror = [value, boundListener];\n        } else {\n          this._onerror = null;\n        }\n      }\n    }, {\n      key: \"onpause\",\n      get: function get() {\n        return this._onpause === null ? this._onpause : this._onpause[0];\n      },\n      set: function set(value) {\n        if (this._onpause !== null) {\n          this.removeEventListener('pause', this._onpause[1]);\n        }\n\n        if (typeof value === 'function') {\n          var boundListener = value.bind(this);\n          this.addEventListener('pause', boundListener);\n          this._onpause = [value, boundListener];\n        } else {\n          this._onpause = null;\n        }\n      }\n    }, {\n      key: \"onresume\",\n      get: function get() {\n        return this._onresume === null ? this._onresume : this._onresume[0];\n      },\n      set: function set(value) {\n        if (this._onresume !== null) {\n          this.removeEventListener('resume', this._onresume[1]);\n        }\n\n        if (typeof value === 'function') {\n          var boundListener = value.bind(this);\n          this.addEventListener('resume', boundListener);\n          this._onresume = [value, boundListener];\n        } else {\n          this._onresume = null;\n        }\n      }\n    }, {\n      key: \"onstart\",\n      get: function get() {\n        return this._onstart === null ? this._onstart : this._onstart[0];\n      },\n      set: function set(value) {\n        if (this._onstart !== null) {\n          this.removeEventListener('start', this._onstart[1]);\n        }\n\n        if (typeof value === 'function') {\n          var boundListener = value.bind(this);\n          this.addEventListener('start', boundListener);\n          this._onstart = [value, boundListener];\n        } else {\n          this._onstart = null;\n        }\n      }\n    }, {\n      key: \"onstop\",\n      get: function get() {\n        return this._onstop === null ? this._onstop : this._onstop[0];\n      },\n      set: function set(value) {\n        if (this._onstop !== null) {\n          this.removeEventListener('stop', this._onstop[1]);\n        }\n\n        if (typeof value === 'function') {\n          var boundListener = value.bind(this);\n          this.addEventListener('stop', boundListener);\n          this._onstop = [value, boundListener];\n        } else {\n          this._onstop = null;\n        }\n      }\n    }, {\n      key: \"state\",\n      get: function get() {\n        return this._internalMediaRecorder.state;\n      }\n    }, {\n      key: \"pause\",\n      value: function pause() {\n        return this._internalMediaRecorder.pause();\n      }\n    }, {\n      key: \"resume\",\n      value: function resume() {\n        return this._internalMediaRecorder.resume();\n      }\n    }, {\n      key: \"start\",\n      value: function start(timeslice) {\n        return this._internalMediaRecorder.start(timeslice);\n      }\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        return this._internalMediaRecorder.stop();\n      }\n    }], [{\n      key: \"isTypeSupported\",\n      value: function isTypeSupported(mimeType) {\n        return nativeMediaRecorderConstructor !== null && // Bug #10: Safari does not yet implement the isTypeSupported() method.\n        nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported(mimeType) || encoderRegexes.some(function (regex) {\n          return regex.test(mimeType);\n        });\n      }\n    }]);\n\n    return MediaRecorder;\n  }(eventTargetConstructor);\n};","map":{"version":3,"mappings":"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","names":["createMediaRecorderConstructor","createNativeMediaRecorder","createNotSupportedError","createWebAudioMediaRecorder","createWebmPcmMediaRecorder","encoderRegexes","eventTargetConstructor","nativeMediaRecorderConstructor","stream","options","mimeType","undefined","isTypeSupported","internalMediaRecorder","_internalMediaRecorder","some","regex","test","_ondataavailable","_onerror","_onpause","_onresume","_onstart","_onstop","value","removeEventListener","boundListener","bind","addEventListener","state","pause","resume","timeslice","start","stop"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\extendable-media-recorder\\src\\factories\\media-recorder-constructor.ts"],"sourcesContent":["import { IMediaRecorder, IMediaRecorderEventMap, IMediaRecorderOptions } from '../interfaces';\nimport {\n    TBlobEventHandler,\n    TErrorEventHandler,\n    TEventHandler,\n    TMediaRecorderConstructorFactory,\n    TNativeEventTarget,\n    TRecordingState\n} from '../types';\n\nexport const createMediaRecorderConstructor: TMediaRecorderConstructorFactory = (\n    createNativeMediaRecorder,\n    createNotSupportedError,\n    createWebAudioMediaRecorder,\n    createWebmPcmMediaRecorder,\n    encoderRegexes,\n    eventTargetConstructor,\n    nativeMediaRecorderConstructor\n) => {\n    return class MediaRecorder extends eventTargetConstructor<IMediaRecorderEventMap> implements IMediaRecorder {\n        private _internalMediaRecorder: Omit<\n            IMediaRecorder,\n            'ondataavailable' | 'onerror' | 'onpause' | 'onresume' | 'onstart' | 'onstop' | keyof TNativeEventTarget\n        >;\n\n        private _ondataavailable: null | [TBlobEventHandler<this>, TBlobEventHandler<this>];\n\n        private _onerror: null | [TErrorEventHandler<this>, TErrorEventHandler<this>];\n\n        private _onpause: null | [TEventHandler<this>, TEventHandler<this>];\n\n        private _onresume: null | [TEventHandler<this>, TEventHandler<this>];\n\n        private _onstart: null | [TEventHandler<this>, TEventHandler<this>];\n\n        private _onstop: null | [TEventHandler<this>, TEventHandler<this>];\n\n        constructor(stream: MediaStream, options: IMediaRecorderOptions = {}) {\n            const { mimeType } = options;\n\n            if (\n                nativeMediaRecorderConstructor !== null &&\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                (mimeType === undefined ||\n                    (nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                        nativeMediaRecorderConstructor.isTypeSupported(mimeType)))\n            ) {\n                const internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n\n                super(internalMediaRecorder);\n\n                this._internalMediaRecorder = internalMediaRecorder;\n            } else if (mimeType !== undefined && encoderRegexes.some((regex) => regex.test(mimeType))) {\n                super();\n\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                if (\n                    nativeMediaRecorderConstructor !== null &&\n                    nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                    nativeMediaRecorderConstructor.isTypeSupported('audio/webm;codecs=pcm')\n                ) {\n                    this._internalMediaRecorder = createWebmPcmMediaRecorder(this, nativeMediaRecorderConstructor, stream, mimeType);\n                } else {\n                    this._internalMediaRecorder = createWebAudioMediaRecorder(this, stream, mimeType);\n                }\n            } else {\n                // This is creating a native MediaRecorder just to provoke it to throw an error.\n                if (nativeMediaRecorderConstructor !== null) {\n                    createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n                }\n\n                throw createNotSupportedError();\n            }\n\n            this._ondataavailable = null;\n            this._onerror = null;\n            this._onpause = null;\n            this._onresume = null;\n            this._onstart = null;\n            this._onstop = null;\n        }\n\n        get mimeType(): string {\n            return this._internalMediaRecorder.mimeType;\n        }\n\n        get ondataavailable(): null | TBlobEventHandler<this> {\n            return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];\n        }\n\n        set ondataavailable(value) {\n            if (this._ondataavailable !== null) {\n                this.removeEventListener('dataavailable', this._ondataavailable[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('dataavailable', boundListener);\n\n                this._ondataavailable = [value, boundListener];\n            } else {\n                this._ondataavailable = null;\n            }\n        }\n\n        get onerror(): null | TErrorEventHandler<this> {\n            return this._onerror === null ? this._onerror : this._onerror[0];\n        }\n\n        set onerror(value) {\n            if (this._onerror !== null) {\n                this.removeEventListener('error', this._onerror[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('error', boundListener);\n\n                this._onerror = [value, boundListener];\n            } else {\n                this._onerror = null;\n            }\n        }\n\n        get onpause(): null | TEventHandler<this> {\n            return this._onpause === null ? this._onpause : this._onpause[0];\n        }\n\n        set onpause(value) {\n            if (this._onpause !== null) {\n                this.removeEventListener('pause', this._onpause[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('pause', boundListener);\n\n                this._onpause = [value, boundListener];\n            } else {\n                this._onpause = null;\n            }\n        }\n\n        get onresume(): null | TEventHandler<this> {\n            return this._onresume === null ? this._onresume : this._onresume[0];\n        }\n\n        set onresume(value) {\n            if (this._onresume !== null) {\n                this.removeEventListener('resume', this._onresume[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('resume', boundListener);\n\n                this._onresume = [value, boundListener];\n            } else {\n                this._onresume = null;\n            }\n        }\n\n        get onstart(): null | TEventHandler<this> {\n            return this._onstart === null ? this._onstart : this._onstart[0];\n        }\n\n        set onstart(value) {\n            if (this._onstart !== null) {\n                this.removeEventListener('start', this._onstart[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('start', boundListener);\n\n                this._onstart = [value, boundListener];\n            } else {\n                this._onstart = null;\n            }\n        }\n\n        get onstop(): null | TEventHandler<this> {\n            return this._onstop === null ? this._onstop : this._onstop[0];\n        }\n\n        set onstop(value) {\n            if (this._onstop !== null) {\n                this.removeEventListener('stop', this._onstop[1]);\n            }\n\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n\n                this.addEventListener('stop', boundListener);\n\n                this._onstop = [value, boundListener];\n            } else {\n                this._onstop = null;\n            }\n        }\n\n        get state(): TRecordingState {\n            return this._internalMediaRecorder.state;\n        }\n\n        public pause(): void {\n            return this._internalMediaRecorder.pause();\n        }\n\n        public resume(): void {\n            return this._internalMediaRecorder.resume();\n        }\n\n        public start(timeslice?: number): void {\n            return this._internalMediaRecorder.start(timeslice);\n        }\n\n        public stop(): void {\n            return this._internalMediaRecorder.stop();\n        }\n\n        public static isTypeSupported(mimeType: string): boolean {\n            return (\n                (nativeMediaRecorderConstructor !== null &&\n                    // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                    nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                    nativeMediaRecorderConstructor.isTypeSupported(mimeType)) ||\n                encoderRegexes.some((regex) => regex.test(mimeType))\n            );\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}