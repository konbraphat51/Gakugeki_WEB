{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/brigh/storage/js_project/Gakugeki_WEB/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nexport var createAudioParamRenderer = function createAudioParamRenderer(automationEventList) {\n  return {\n    replay: function replay(audioParam) {\n      var _iterator = _createForOfIteratorHelper(automationEventList),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var automationEvent = _step.value;\n\n          if (automationEvent.type === 'exponentialRampToValue') {\n            var endTime = automationEvent.endTime,\n                value = automationEvent.value;\n            audioParam.exponentialRampToValueAtTime(value, endTime);\n          } else if (automationEvent.type === 'linearRampToValue') {\n            var _endTime = automationEvent.endTime,\n                _value = automationEvent.value;\n            audioParam.linearRampToValueAtTime(_value, _endTime);\n          } else if (automationEvent.type === 'setTarget') {\n            var startTime = automationEvent.startTime,\n                target = automationEvent.target,\n                timeConstant = automationEvent.timeConstant;\n            audioParam.setTargetAtTime(target, startTime, timeConstant);\n          } else if (automationEvent.type === 'setValue') {\n            var _startTime = automationEvent.startTime,\n                _value2 = automationEvent.value;\n            audioParam.setValueAtTime(_value2, _startTime);\n          } else if (automationEvent.type === 'setValueCurve') {\n            var duration = automationEvent.duration,\n                _startTime2 = automationEvent.startTime,\n                values = automationEvent.values;\n            audioParam.setValueCurveAtTime(values, _startTime2, duration);\n          } else {\n            throw new Error(\"Can't apply an unknown automation.\");\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  };\n};","map":{"version":3,"mappings":";AAEA,OAAO,IAAMA,wBAAwB,GAA+B,SAAvDA,wBAAuD,CAACC,mBAAD,EAAwB;EACxF,OAAO;IACHC,MADG,kBACIC,UADJ,EACiC;MAAA,2CACFF,mBADE;MAAA;;MAAA;QAChC,oDAAmD;UAAA,IAAxCG,eAAwC;;UAC/C,IAAIA,eAAe,CAACC,IAAhB,KAAyB,wBAA7B,EAAuD;YACnD,IAAQC,OAAR,GAA2BF,eAA3B,CAAQE,OAAR;YAAA,IAAiBC,KAAjB,GAA2BH,eAA3B,CAAiBG,KAAjB;YAEAJ,UAAU,CAACK,4BAAX,CAAwCD,KAAxC,EAA+CD,OAA/C;UACH,CAJD,MAIO,IAAIF,eAAe,CAACC,IAAhB,KAAyB,mBAA7B,EAAkD;YACrD,IAAQC,QAAR,GAA2BF,eAA3B,CAAQE,OAAR;YAAA,IAAiBC,MAAjB,GAA2BH,eAA3B,CAAiBG,KAAjB;YAEAJ,UAAU,CAACM,uBAAX,CAAmCF,MAAnC,EAA0CD,QAA1C;UACH,CAJM,MAIA,IAAIF,eAAe,CAACC,IAAhB,KAAyB,WAA7B,EAA0C;YAC7C,IAAQK,SAAR,GAA4CN,eAA5C,CAAQM,SAAR;YAAA,IAAmBC,MAAnB,GAA4CP,eAA5C,CAAmBO,MAAnB;YAAA,IAA2BC,YAA3B,GAA4CR,eAA5C,CAA2BQ,YAA3B;YAEAT,UAAU,CAACU,eAAX,CAA2BF,MAA3B,EAAmCD,SAAnC,EAA8CE,YAA9C;UACH,CAJM,MAIA,IAAIR,eAAe,CAACC,IAAhB,KAAyB,UAA7B,EAAyC;YAC5C,IAAQK,UAAR,GAA6BN,eAA7B,CAAQM,SAAR;YAAA,IAAmBH,OAAnB,GAA6BH,eAA7B,CAAmBG,KAAnB;YAEAJ,UAAU,CAACW,cAAX,CAA0BP,OAA1B,EAAiCG,UAAjC;UACH,CAJM,MAIA,IAAIN,eAAe,CAACC,IAAhB,KAAyB,eAA7B,EAA8C;YACjD,IAAQU,QAAR,GAAwCX,eAAxC,CAAQW,QAAR;YAAA,IAAkBL,WAAlB,GAAwCN,eAAxC,CAAkBM,SAAlB;YAAA,IAA6BM,MAA7B,GAAwCZ,eAAxC,CAA6BY,MAA7B;YAEAb,UAAU,CAACc,mBAAX,CAA+BD,MAA/B,EAAuCN,WAAvC,EAAkDK,QAAlD;UACH,CAJM,MAIA;YACH,MAAM,IAAIG,KAAJ,CAAU,oCAAV,CAAN;UACH;QACJ;MAzB+B;QAAA;MAAA;QAAA;MAAA;IA0BnC;EA3BE,CAAP;AA6BH,CA9BM","names":["createAudioParamRenderer","automationEventList","replay","audioParam","automationEvent","type","endTime","value","exponentialRampToValueAtTime","linearRampToValueAtTime","startTime","target","timeConstant","setTargetAtTime","setValueAtTime","duration","values","setValueCurveAtTime","Error"],"sources":["C:\\Users\\brigh\\storage\\js_project\\Gakugeki_WEB\\node_modules\\standardized-audio-context\\src\\factories\\audio-param-renderer.ts"],"sourcesContent":["import { TAudioParamRendererFactory, TNativeAudioParam } from '../types';\n\nexport const createAudioParamRenderer: TAudioParamRendererFactory = (automationEventList) => {\n    return {\n        replay(audioParam: TNativeAudioParam): void {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                } else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n\n                    audioParam.setValueAtTime(value, startTime);\n                } else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                } else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module"}